import time
import logging
import concurrent.futures
import re
import socket

import urllib3
import requests
from decouple import config
from ntc_templates.parse import parse_output
from netmiko import ConnectHandler
import pynautobot

# Отключаем предупреждения InsecureRequestWarning
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Константы из окружения
HPNA_LOGIN = config('HPNA_LOGIN')
HPNA_PASSWORD = config('HPNA_PASSWORD')
NAUTOBOT_URL = config('NAUTOBOT_URL')
NAUTOBOT_TOKEN = config('NAUTOBOT_TOKEN')

# Для тестирования - укажите проблемное устройство
TEST_DEVICE = "MS-EKB00-01"  # Замените на ваше устройство

# Основной логгер
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s'
)
logger = logging.getLogger(__name__)

# Отдельный debug logger для диагностики
debug_logger = logging.getLogger('debug')
debug_handler = logging.FileHandler('debug.log')
debug_handler.setFormatter(logging.Formatter('%(asctime)s %(message)s'))
debug_logger.addHandler(debug_handler)
debug_logger.setLevel(logging.DEBUG)


def netmiko_connect(nautobot_device, device_type):
    """Создает подключение к сетевому устройству через Netmiko."""
    netmiko_device = {
        'device_type': device_type,
        'host': str(nautobot_device.primary_ip4)[:-3:],
        'username': config('HPNA_LOGIN'),
        'password': config('HPNA_PASSWORD'),
        'timeout': 200,
        'port': 22,
        "global_delay_factor": 2,
        'conn_timeout': 200
    }

    try:
        net_connect = ConnectHandler(**netmiko_device)
    except Exception as error:
        try:
            net_connect = ConnectHandler(**netmiko_device)
        except Exception as error:
            logger.error(f"Connection error {nautobot_device}")
            return None

    return net_connect


def nautobot_connection():
    """Возвращает клиент pynautobot с увеличенным пулом соединений."""
    api = pynautobot.api(
        NAUTOBOT_URL,
        token=NAUTOBOT_TOKEN,
        verify=False,
    )
    adapter = requests.adapters.HTTPAdapter(
        pool_connections=1000,
        pool_maxsize=1000
    )
    api.http_session.mount('http://', adapter)
    api.http_session.mount('https://', adapter)
    api.http_session.verify = False
    return api


def format_mac_address(mac_address):
    """Преобразует MAC-адрес в формат aa-bb-cc-dd-ee-ff."""
    mac_parts = mac_address.split('.')
    mac_joined = ''.join(mac_parts)
    blocks = [mac_joined[x:x + 2] for x in range(0, len(mac_joined), 2)]
    return '-'.join(blocks)


def get_dns_name(ip_address):
    """Получает DNS имя для IP-адреса."""
    try:
        dns_name, alias, address_list = socket.gethostbyaddr(ip_address)
        return re.sub(r'[#*\s\[\]\"]', '', dns_name)
    except Exception:
        return ''


def get_ips_in_vrf_safe(nautobot_api, vrf_id, vrf_name):
    """
    Получает IP-адреса в VRF через префиксы с альтернативным подходом из-за бага API.
    Обходит проблему с filter(vrf=vrf_id) используя all() и ручную фильтрацию.
    """
    try:
        debug_logger.info(f"\n=== GETTING IPs FOR VRF {vrf_name} ({vrf_id}) ===")
        
        # ОБХОДНОЕ РЕШЕНИЕ: получаем ВСЕ assignments и фильтруем вручную
        debug_logger.info("Using alternative approach due to API filter bug")
        all_assignments = nautobot_api.ipam.vrf_prefix_assignments.all()
        vrf_assignments = [a for a in all_assignments if a.vrf.id == vrf_id]
        prefix_ids = [a.prefix.id for a in vrf_assignments]
        
        debug_logger.info(f"Alternative method found {len(prefix_ids)} prefixes for VRF {vrf_name}")
        
        # Сравнение с оригинальным методом для диагностики
        try:
            original_assignments = nautobot_api.ipam.vrf_prefix_assignments.filter(vrf=vrf_id)
            original_prefix_ids = [a.prefix.id for a in original_assignments]
            debug_logger.info(f"Original filter method found {len(original_prefix_ids)} prefixes")
            
            # Находим различия
            missing_in_filter = set(prefix_ids) - set(original_prefix_ids)
            if missing_in_filter:
                debug_logger.error(f"BUG CONFIRMED: {len(missing_in_filter)} prefixes missing in filter method:")
                for missing_id in missing_in_filter:
                    try:
                        prefix_obj = nautobot_api.ipam.prefixes.get(missing_id)
                        debug_logger.error(f"  Missing prefix: {prefix_obj.prefix} (ID: {missing_id})")
                    except:
                        debug_logger.error(f"  Missing prefix ID: {missing_id}")
            else:
                debug_logger.info("No differences between alternative and filter methods")
                
        except Exception as compare_error:
            debug_logger.error(f"Error comparing methods: {compare_error}")
        
        # Проверяем конкретный проблемный префикс
        missing_prefix_id = "40433cfa-cc98-4879-b38e-ccb1303134e6"
        if missing_prefix_id in prefix_ids:
            debug_logger.info(f"SUCCESS: Prefix {missing_prefix_id} FOUND with alternative method")
        else:
            debug_logger.error(f"STILL MISSING: Prefix {missing_prefix_id} not found even with alternative method")
        
        vrf_ips = []
        error_count = 0
        processed_count = 0
        
        for i, prefix_id in enumerate(prefix_ids):
            try:
                prefix_obj = nautobot_api.ipam.prefixes.get(prefix_id)
                ip_addresses = nautobot_api.ipam.ip_addresses.filter(parent=prefix_id)
                found_ips = [ip.address for ip in ip_addresses]
                
                # Логируем только если есть проблемы или это проблемный префикс
                if prefix_id == missing_prefix_id or len(found_ips) == 0:
                    debug_logger.info(f"Prefix {i+1}: {prefix_obj.prefix} (ID: {prefix_id})")
                    debug_logger.info(f"  Found {len(found_ips)} IPs: {found_ips}")
                
                vrf_ips.extend(found_ips)
                processed_count += 1
                
            except Exception as prefix_error:
                error_count += 1
                debug_logger.error(f"Error processing prefix {prefix_id}: {prefix_error}")
        
        if error_count > 0:
            debug_logger.error(f"VRF {vrf_name}: {error_count} prefix errors out of {len(prefix_ids)}")
        
        debug_logger.info(f"Processed {processed_count}/{len(prefix_ids)} prefixes successfully")
        debug_logger.info(f"TOTAL IPs in VRF {vrf_name}: {len(vrf_ips)}")
        debug_logger.info(f"=== END VRF {vrf_name} ===\n")
        
        return vrf_ips
        
    except Exception as error:
        debug_logger.error(f"Error getting IPs for VRF {vrf_id}: {error}")
        return []


def handle_existing_ip_error(nautobot_api, ip_address, vrf_id):
    """
    Обрабатывает ошибку существующего IP-адреса.
    Добавляет VRF к префиксу, если его там нет.
    """
    try:
        # Находим существующий IP-адрес
        existing_ip = nautobot_api.ipam.ip_addresses.get(address=ip_address)
        if not existing_ip:
            logger.error(f"Cannot find existing IP {ip_address}")
            return False
            
        if not existing_ip.parent:
            logger.error(f"IP {ip_address} has no parent prefix")
            return False
            
        prefix_id = existing_ip.parent.id
        
        # Проверяем, есть ли уже нужный VRF у префикса
        existing_vrf_assignments = nautobot_api.ipam.vrf_prefix_assignments.filter(prefix=prefix_id)
        existing_vrf_ids = [assignment.vrf.id for assignment in existing_vrf_assignments]
        
        if vrf_id not in existing_vrf_ids:
            # Добавляем VRF к префиксу
            nautobot_api.ipam.vrf_prefix_assignments.create(
                prefix=prefix_id,
                vrf=vrf_id
            )
            logger.info(f"Added VRF {vrf_id} to prefix {existing_ip.parent.prefix}")
        else:
            logger.info(f"VRF {vrf_id} already assigned to prefix {existing_ip.parent.prefix}")
        
        return True
        
    except Exception as error:
        logger.error(f"Error handling existing IP {ip_address}: {error}")
        return False


def create_ip_address_in_nautobot(nautobot_api, arp_entry, dns_name, vrf_id, vrf_name, device_name):
    """Создает IP-адрес в Nautobot с обработкой конфликтов."""
    ip_address = f"{arp_entry['address']}/32"
    
    # Диагностика только для конкретных проблемных IP
    is_debug_ip = arp_entry['address'] in ['172.27.53.1', '192.168.8.20']  # Добавьте свои проблемные IP
    
    # Дополнительная проверка существования IP перед созданием
    try:
        existing_ip = nautobot_api.ipam.ip_addresses.get(address=ip_address)
        if existing_ip:
            logger.warning(f"IP {ip_address} already exists but wasn't found in VRF {vrf_name} check for device {device_name}")
            
            if is_debug_ip:
                debug_logger.info(f"\n=== DEBUGGING IP {ip_address} ===")
                debug_logger.info(f"Device: {device_name}")
                debug_logger.info(f"VRF: {vrf_name} ({vrf_id})")
                debug_logger.info(f"Existing IP parent: {existing_ip.parent}")
                debug_logger.info(f"Existing IP parent prefix: {existing_ip.parent.prefix if existing_ip.parent else 'NO PARENT'}")
                
                if existing_ip.parent:
                    debug_logger.info(f"Existing IP parent ID: {existing_ip.parent.id}")
                    
                    # Проверяем к каким VRF привязан родительский префикс
                    parent_assignments = nautobot_api.ipam.vrf_prefix_assignments.filter(prefix=existing_ip.parent.id)
                    parent_vrfs = [f"{a.vrf.name} ({a.vrf.id})" for a in parent_assignments]
                    debug_logger.info(f"Parent prefix VRFs: {parent_vrfs}")
                    
                    # Проверяем, есть ли этот parent среди префиксов текущего VRF
                    vrf_prefix_assignments = nautobot_api.ipam.vrf_prefix_assignments.filter(vrf=vrf_id)
                    vrf_prefix_ids = [a.prefix.id for a in vrf_prefix_assignments]
                    debug_logger.info(f"Current VRF has {len(vrf_prefix_ids)} prefixes")
                    debug_logger.info(f"IP parent in current VRF prefixes: {existing_ip.parent.id in vrf_prefix_ids}")
                    
                    # Дополнительная проверка - получаем IP через фильтр parent
                    test_ips = nautobot_api.ipam.ip_addresses.filter(parent=existing_ip.parent.id)
                    test_ip_addresses = [ip.address for ip in test_ips]
                    debug_logger.info(f"IPs found by parent filter: {test_ip_addresses}")
                    debug_logger.info(f"Our IP in parent filter results: {ip_address in test_ip_addresses}")
                    
                    # Проверяем статус prefix assignment
                    debug_logger.info(f"=== CHECKING PREFIX ASSIGNMENT STATUS ===")
                    try:
                        all_assignments_for_prefix = nautobot_api.ipam.vrf_prefix_assignments.filter(prefix=existing_ip.parent.id)
                        debug_logger.info(f"All assignments for prefix {existing_ip.parent.id}:")
                        for assignment in all_assignments_for_prefix:
                            debug_logger.info(f"  VRF: {assignment.vrf.name} ({assignment.vrf.id})")
                    except Exception as e:
                        debug_logger.error(f"Error checking prefix assignments: {e}")
                
                debug_logger.info(f"=== END DEBUG ===\n")
            
            # Пытаемся исправить VRF assignment
            handle_existing_ip_error(nautobot_api, ip_address, vrf_id)
            return
    except Exception as e:
        # IP не существует, можно создавать
        if is_debug_ip:
            debug_logger.info(f"IP {ip_address} does not exist, will create: {e}")
        pass
    
    try:
        nautobot_api.ipam.ip_addresses.create([{
            "address": ip_address,
            "custom_fields": {
                "mac_address": arp_entry['mac']
            },
            "dns_name": dns_name,
            "status": "Active",
            "namespace": "ed1a3ab7-deea-4872-b111-b44513de94a8"
        }])
        # Логируем только если это debug IP
        if is_debug_ip:
            logger.info(f"Created IP address {ip_address} for device {device_name}")
        
    except Exception as error:
        logger.warning(f"Failed to create IP {ip_address} for device {device_name}: {error}")
        
        # Пытаемся обработать конфликт VRF
        if "already exists" in str(error).lower():
            if handle_existing_ip_error(nautobot_api, ip_address, vrf_id):
                logger.info(f"VRF conflict resolved for IP {ip_address}, device {device_name}")
            else:
                logger.error(f"Could not resolve VRF conflict for IP {ip_address}, device {device_name}")
        else:
            logger.error(f"Unexpected error creating IP {ip_address} for device {device_name}: {error}")


def create_arp_nautobot_on_cisco_ios(nautobot_device, nautobot_api):
    """Обрабатывает ARP записи для устройств Cisco IOS."""
    net_connect = netmiko_connect(nautobot_device, 'cisco_ios')

    if not net_connect:
        return

    try:
        device_vrfs = nautobot_api.ipam.vrfs.filter(device=nautobot_device.id)
        existing_vrf_in_device = {vrf.name: vrf.id for vrf in device_vrfs}

        for vrf_name, vrf_id in existing_vrf_in_device.items():
            logger.info(f"Processing VRF {vrf_name} for device {nautobot_device.name}")
            
            # Безопасно получаем IP-адреса в VRF
            nautobot_device_arp = get_ips_in_vrf_safe(nautobot_api, vrf_id, vrf_name)
            
            # Получаем ARP-таблицу с устройства
            output = net_connect.send_command(f'show ip arp vrf {vrf_name}', read_timeout=200)
            device_arp = parse_output(platform='cisco_ios', command='show ip arp', data=output)

            # Форматируем MAC-адреса
            for arp_entry in device_arp:
                arp_entry['mac'] = format_mac_address(arp_entry['mac'])

            # Обрабатываем каждую ARP запись
            for arp_entry in device_arp:
                skip_list = [
                    '192.168.0.0', '192.168.0.1', '192.168.0.2',
                    '192.168.0.3', '192.168.0.4', '192.168.0.5',
                    '192.168.0.6'
                ]

                # Пропускаем служебные IP-адреса
                if any(sub in arp_entry['address'] for sub in skip_list):
                    continue

                # Пропускаем неполные MAC-адреса
                if str(arp_entry['mac']).upper() == 'IN-CO-MP-LE-TE':
                    continue

                # Получаем DNS имя
                dns_name = get_dns_name(arp_entry['address'])

                # Создаем IP-адрес, если его нет в VRF
                ip_with_mask = f"{arp_entry['address']}/32"
                if ip_with_mask not in nautobot_device_arp:
                    create_ip_address_in_nautobot(nautobot_api, arp_entry, dns_name, vrf_id, vrf_name, nautobot_device.name)

        net_connect.disconnect()
        logger.info(f'Completed processing device {nautobot_device.name}')
        
    except Exception as error:
        logger.error(f'Error processing device {nautobot_device.name}: {error}')


def create_arp_nautobot_on_cisco_nxos(nautobot_device, nautobot_api):
    """Обрабатывает ARP записи для устройств Cisco NXOS."""
    net_connect = netmiko_connect(nautobot_device, 'cisco_nxos')

    if not net_connect:
        return

    try:
        device_vrfs = nautobot_api.ipam.vrfs.filter(device=nautobot_device.id)
        existing_vrf_in_device = {vrf.name: vrf.id for vrf in device_vrfs}

        for vrf_name, vrf_id in existing_vrf_in_device.items():
            logger.info(f"Processing VRF {vrf_name} for device {nautobot_device.name}")
            
            # Безопасно получаем IP-адреса в VRF
            nautobot_device_arp = get_ips_in_vrf_safe(nautobot_api, vrf_id, vrf_name)

            # Получаем ARP-таблицу с устройства
            output = net_connect.send_command(f'show ip arp vrf {vrf_name}', read_timeout=200)
            device_arp = parse_output(platform='cisco_nxos', command='show ip arp', data=output)

            # Форматируем MAC-адреса
            for arp_entry in device_arp:
                arp_entry['mac'] = format_mac_address(arp_entry['mac'])

            # Обрабатываем каждую ARP запись
            for arp_entry in device_arp:
                # Пропускаем неполные MAC-адреса
                if str(arp_entry['mac']).upper() == 'IN-CO-MP-LE-TE':
                    continue

                # Получаем DNS имя
                dns_name = get_dns_name(arp_entry['address'])

                # Создаем IP-адрес, если его нет в VRF
                ip_with_mask = f"{arp_entry['address']}/32"
                if ip_with_mask not in nautobot_device_arp:
                    create_ip_address_in_nautobot(nautobot_api, arp_entry, dns_name, vrf_id, vrf_name, nautobot_device.name)

        net_connect.disconnect()
        logger.info(f'Completed processing device {nautobot_device.name}')
        
    except Exception as error:
        logger.error(f'Error processing device {nautobot_device.name}: {error}')


def add_arp_entry_to_nautobot():
    """Основная функция для добавления ARP записей в Nautobot."""
    start_time = time.time()
    api = nautobot_connection()

    # Строим мапу тегов
    all_tags = list(api.extras.tags.all())
    tag_map = {tag.id: tag.name for tag in all_tags}

    # Фильтруем нужные устройства
    devices = list(api.dcim.devices.all())
    target_devices = []
    
    for device in devices:
        tag_names = [tag_map.get(tag.id) for tag in (device.tags or [])]
        if 'raif_scripts' in tag_names:
            target_devices.append(device)

    logger.info(f"Found {len(target_devices)} target devices")
    
    # Для тестирования - только одно устройство без многопоточности
    for nautobot_device in target_devices:
        if nautobot_device.name != TEST_DEVICE:
            continue
            
        logger.info(f"Processing test device: {nautobot_device.name}")
        
        if nautobot_device.platform and nautobot_device.platform.name == 'Cisco NXOS':
            create_arp_nautobot_on_cisco_nxos(nautobot_device, api)
        elif nautobot_device.platform and nautobot_device.platform.name == 'Cisco IOS':
            create_arp_nautobot_on_cisco_ios(nautobot_device, api)

    execution_time = time.time() - start_time
    logger.info(f"Script execution completed in {execution_time:.2f} seconds")
    debug_logger.info(f"Debug log saved to debug.log")


if __name__ == "__main__":
    add_arp_entry_to_nautobot()
