import json
import asyncio
import logging
from typing import Union, Dict, List, Any, Optional

from ttp import ttp

from tools import (NA,
                   settings,
                   AsyncNetworkDevice,
                   AsyncAPIClient,
                   hpna_get_device_list,
                   INTERFACE_TEMPLATE_PATH,
                   load_template,
                   DataNormalizer,
                   NautobotCreatePrefixModel,
                   Interface,
                   PrefixInfo,
                   VRF)

logger = logging.getLogger(__name__)

PREFIXES_TO_SKIP = (
    "192.168.127.0/24",     # dmvpn prefix
    "192.168.129.0/24",     # dmvpn prefix
    "192.168.162.0/24",     # dmvpn prefix
    "192.168.121.0/24",     # dmvpn prefix
    "192.168.173.0/24",     # dmvpn prefix
    "192.168.122.0/24",     # dmvpn prefix
    "192.168.0.0/31",       # p2p prefix in Branches
    "192.168.0.2/31",       # p2p prefix in Branches
    "192.168.0.4/31",       # p2p prefix in Branches
    "192.168.0.6/31",       # p2p prefix in Branches
    "1.1.1.0/30"            # p2p prefix in Branches
    "172.28.7.0/31"         # p2p prefix in Branches
)

VRFS_TO_SKIP = (
    "PEER-KEEPALIVE",   # Cisco NXOS VPC vrf
    "VPC_KEEPALIVE",    # Cisco NXOS VPC vrf
    "management",       # Cisco NXOS standard mgmt vrf
    "Mgmt-vrf",         # Cisco Catalyst standard mgmt vrf
    "Mgmt-intf",        # Cisco IOS standard mgmt vrf
    "mgmtVrf",          # Cisco IOS standard mgmt vrf
)


async def send_cli_worker(device: dict,
                          cli_command: Union[str, list],
                          semaphore: asyncio.Semaphore):
    """
    Worker function for sending cli commands to network devices

    Args:
        device (dict): Dictionary that contains network device parameters
        cli_command (Union[str, list]): single show command or a list of show commands
        semaphore (asyncio.Semaphore): Semaphore to limit the number
            of concurrent connections

    Returns:
        coroutine or None
    """

    max_retries = 2
    backoff_seconds = 3
    failed = False

    for attempt in range(1, max_retries + 1):
        try:
            async with AsyncNetworkDevice(
                    host=device["host"],
                    auth_username=device["auth_username"],
                    auth_password=device["auth_password"],
                    platform=device["platform"],
                    auth_strict_key=device["auth_strict_key"],
                    ssh_config_file=device.get("ssh_config_file"),
                    ttp_template=device.get("ttp_template"),
                    semaphore=semaphore,
            ) as dev:
                return await dev.send_show_parse(cli_command)

        except Exception as e:
            logger.warning(f"{device['host']} [Attempt {attempt}/{max_retries}] failed: {e}")

            if attempt < max_retries:
                # Wait before the next retry
                await asyncio.sleep(backoff_seconds)
            else:
                # If this was the last attempt, log it as an error
                logger.error(
                    f"{device['host']} - all {max_retries} connection attempts failed."
                )
                failed = True

    if failed:
        logger.warning(f"{device['host']} - falling back to HPNA.")

        na = NA(settings.HPNA_HOSTNAME,
                settings.HPNA_USERNAME,
                settings.HPNA_PASSWORD)

        logger.info(f"{device['host']} - getting config from HPNA.")

        device_config = na.show_device_config(ip=device["host"]).get("result")
        if device_config:
            logger.info(f"{device['host']} - got config from HPNA.")

            ttp_template_path = INTERFACE_TEMPLATE_PATH.get(device["platform"])
            logger.info(f"{device['host']} - Template: {ttp_template_path}")

            ttp_template = load_template(ttp_template_path)
            parser = ttp(template=ttp_template)
            parser.add_input(device_config)
            parser.parse()
            result = parser.result()
            return result[0][0][0]

    return None


async def get_device_interface_data():
    """
    Gets a list of network devices from the HPNA and runs show run across the
    devices in the list
    """
    device_list = hpna_get_device_list(hostname=settings.HPNA_HOSTNAME,
                                       hpna_username=settings.HPNA_USERNAME,
                                       hpna_password=settings.HPNA_PASSWORD)
    total_devices = len(device_list)
    no_result = 0
    logger.info(f"Found {len(device_list)} network devices")

    semaphore = asyncio.Semaphore(20)
    running_config_tasks = list()
    for device in device_list:
        cli = "show running-config"
        if device["platform"] == "huawei_vrp":
            cli = "display current"

        running_config_tasks.append(send_cli_worker(device, cli, semaphore))

    results = await asyncio.gather(*running_config_tasks, return_exceptions=True)
    for result in results:
        if not result:
            no_result += 1
            continue

    logger.info(f"Total network devices: {total_devices}"),
    logger.info(f"Devices failed to parse: {no_result}")
    logger.info(f"Total devices parsed: {total_devices - no_result}")

    return results


async def get_nautobot_graphql_data(hostname: str,
                                    token: str,
                                    endpoint: str) -> Optional[Any]:
    """
    Gets data from Nautobot GraphQL API endpoint

    Args:
        hostname (str): Nautobot hostname
        token (str): Nautobot token
        endpoint (str): Nautobot endpoint

    Returns:
        JSON response or None
    """
    async with AsyncAPIClient(base_address=hostname, token=token, timeout=90) as api:
        try:
            response = await api.post(path=endpoint)
            return response.json()
        except Exception as e:
            logger.exception(
                f"Request failed to obtain GraphQL data from Nautobot",
                exc_info=e,
                stack_info=True,
                stacklevel=5
            )

        return None


def get_vrf_id(prefix: Interface,
               vrf_data: Dict[str, List[Any]],
               hostname: str) -> Optional[VRF]:
    """
    Return the VRF ID for the given prefix and device hostname,
    or None if no matching VRF is found or it's skipped.

    Args:
        prefix (Interface): Prefix data fetched from the device interface
        vrf_data (dict): Dictionary that contains list vrf data grouped by device name
        hostname (str): device hostname

    Returns:
        UUID of the vrf or None
    """
    logger.debug(f"Looking up VRF for prefix '{prefix.vrf}' on host '{hostname}'")
    vrfs = vrf_data.get(hostname, []) or []
    for vrf in vrfs:
        # skip any VRF names that are in the stop-list
        if vrf.name in VRFS_TO_SKIP:
            continue
        if prefix.vrf == vrf.name:
            return vrf
    return None


async def create_and_map_vrf2prefix(prefix: Interface,
                                    existing_prefixes: Dict[str, PrefixInfo],
                                    vrf_data: Dict[str, List[VRF]],
                                    hostname: str,
                                    nautobot_api: AsyncAPIClient
                                    ) -> Optional[PrefixInfo]:
    """
    Creates a prefix and a vrf to prefix assignment

    Args:
        prefix (Interface): Prefix data fetched from the device interface
        existing_prefixes (Dict[str, PrefixInfo]): Dictionary that contains existing in Nautobot prefixes
        vrf_data (dict): Dictionary that contains list vrf data grouped by device name
        hostname (str): device hostname
        nautobot_api (AsyncAPIClient): Nautobot API client
        lock (asyncio.Lock): Lock to prevent race conditions

    Returns:
        None
    """

    # Checking if prefix is on the skip list
    if prefix.prefix in PREFIXES_TO_SKIP or "/32" in prefix.prefix:
        return

    if prefix.prefix in existing_prefixes:
        return

    # create a prefix model to use in a POST request
    create_prefix = NautobotCreatePrefixModel(prefix=prefix.prefix)
    logger.info(f"Prefix {prefix.prefix} not found in Nautobot")

    try:
        logger.info(f"Attempting to create a prefix {prefix.prefix}")
        response = await nautobot_api.post(
            path="ipam/prefixes/",
            json=create_prefix.as_dict()
        )
        response.raise_for_status()
        prefix_id = response.json()["id"]
        logger.info(f"Created prefix {prefix.prefix} --> prefix id: {prefix_id}")
        created_prefix = PrefixInfo(id=prefix_id,
                                    prefix=prefix.prefix,
                                    vrfs=[],
                                    vrf_assignments=[])
    except Exception as e:
        logger.exception(
            f"Failed to create prefix {prefix.prefix}",
            exc_info=e,
            stack_info=True,
            stacklevel=5
        )
        return

    vrf_id = get_vrf_id(prefix, vrf_data, hostname)
    if not vrf_id:
        return

    try:
        vrf_prefix_map = {"prefix": prefix_id, "vrf": vrf_id.id}
        response = await nautobot_api.post(
                    path="ipam/vrf-prefix-assignments/",
                    json=vrf_prefix_map
                )
        response.raise_for_status()
        logger.info(f"Prefix {prefix.prefix}(id={prefix_id}) mapped to VRF {prefix.vrf}(id={vrf_id.id})")
        created_prefix.vrfs.append(
            VRF(id=vrf_id.id, name=vrf_id.name)
        )
        created_prefix.vrf_assignments.append(
            {"id": response.json()["id"]}
        )
        return created_prefix

    except Exception as e:
        logger.exception(
            f"Failed to create vrf prefix assignment for {prefix.prefix}(id={prefix_id}) and vrf {prefix.vrf}(id={vrf_id.id})",
            exc_info=e,
            stack_info=True,
            stacklevel=5
        )
        return created_prefix


async def collect_data() -> tuple:
    """
    Collects data from devices and nautobot

    Returns:
        A tuple with the following items:
            - existing prefixes from nautobot
            - devices interface data
            - vrf to device assignments data
            - prefix to vrf mappings
    """
    # getting interface data from network devices
    device_interface_data_task = get_device_interface_data()
    # endpoint of the saved graphql query to get vrfs attached to the device
    get_device_vrfs_endpoint = "extras/graphql-queries/30800416-82e6-491b-8d10-0c89578fca55/run/"

    logger.info("Getting vrf to device assignments from Nautobot GraphQL")
    # retrieving vrf data from nautobot
    device_vrfs_task = get_nautobot_graphql_data(
        hostname=settings.NAUTOBOT_HOSTNAME,
        token=settings.NAUTOBOT_TOKEN,
        endpoint=get_device_vrfs_endpoint)

    # endpoint of the saved graphql query to get prefixes details
    get_prefixes_endpoint = "extras/graphql-queries/21f468d2-e225-44b1-9010-6071b6b2d4c3/run/"

    logger.info("Getting prefixes details from Nautobot GraphQL")
    # retrieving prefixes data from nautobot
    prefixes_task = get_nautobot_graphql_data(
        hostname=settings.NAUTOBOT_HOSTNAME,
        token=settings.NAUTOBOT_TOKEN,
        endpoint=get_prefixes_endpoint)

    device_interface_data, device_vrfs, prefixes = await asyncio.gather(
        device_interface_data_task,
        device_vrfs_task,
        prefixes_task,
        return_exceptions=True
    )

    # normalizing retrieved data
    normalized_data = DataNormalizer(
        prefix_data=prefixes,
        device_vrf_info=device_vrfs,
        interface_data=device_interface_data,
    )

    return (
        normalized_data.prefix_data,
        normalized_data.interface_data.devices,
        normalized_data.device_vrf_info,
        normalized_data.prefix2vrf_mappings
    )


async def remove_stale_vrf_assignment(prefix: str, vrf_list: list[str],
                                      prefixes: dict,
                                      nautobot_api: AsyncAPIClient):

    nautobot_prefix = prefixes.get(prefix)
    if not nautobot_prefix or not nautobot_prefix.vrfs:
        return

    device_prefix_vrfs = set(vrf_list)
    nautobot_prefix_vrfs = {vrf.name for vrf in nautobot_prefix.vrfs}

    vrf_diff = nautobot_prefix_vrfs - device_prefix_vrfs
    if not vrf_diff:
        return

    vrf_name = vrf_diff.pop()
    logger.info(f"Prefix {prefix}(id={nautobot_prefix.id}) VRF DIFF: {vrf_name}")

    graphql_query_str = f"""
        query GetPrefixes {{
            prefixes(id: "{nautobot_prefix.id}") {{
                id
                prefix
                vrf_assignments(vrf: "{vrf_name}") {{
                    id
                }}
            }}
        }}
    """

    try:
        gql_response = await nautobot_api.graphql_query_run(query=graphql_query_str)
        logger.debug(json.dumps(gql_response.json(), indent=4))
        vrf_assignment_id = gql_response.json()["data"]["prefixes"][0]["vrf_assignments"][0]["id"]
    except (IndexError, KeyError) as e:
        logger.exception("Failed to get vrf assignment id", exc_info=e)
        return
    except Exception as e:
        logger.exception("Failed to query GraphQL", exc_info=e)
        return

    try:
        logger.info(f"Deleting VRF assignment {vrf_name}(id={vrf_assignment_id}) for prefix "
                    f"{nautobot_prefix.prefix}(id={nautobot_prefix.id})")
        await nautobot_api.delete(
            path="ipam/vrf-prefix-assignments/",
            json=[{"id": vrf_assignment_id}],
        )
        logger.info(f"VRF assignment {vrf_name}(id={vrf_assignment_id}) for prefix "
                    f"{nautobot_prefix.prefix}(id={nautobot_prefix.id}) removed")
    except Exception as e:
        logger.exception(f"Failed to delete vrf assignment {vrf_name}(id={vrf_assignment_id})", exc_info=e)


async def process_prefix_vrf_mapping(prefix: Interface,device_hostname: str,
                                     prefixes: dict, vrf_data: dict,
                                     nautobot_api: AsyncAPIClient,
                                     lock: asyncio.Lock,
                                     semaphore: asyncio.Semaphore):

    async with semaphore:
        created_prefix = await create_and_map_vrf2prefix(
            prefix=prefix,
            existing_prefixes=prefixes,
            vrf_data=vrf_data,
            hostname=device_hostname,
            nautobot_api=nautobot_api
        )

        if created_prefix:
            async with lock:
                prefixes[prefix.prefix] = created_prefix
            return

        if not prefix.vrf or prefix.vrf in VRFS_TO_SKIP or prefix.prefix in PREFIXES_TO_SKIP:
            return

        nautobot_prefix = prefixes.get(prefix.prefix)
        if not nautobot_prefix:
            return

        vrf_match = any(vrf.name == prefix.vrf for vrf in nautobot_prefix.vrfs or [])
        if vrf_match:
            return

        logger.warning(f"Prefix {prefix.prefix} vrf {prefix.vrf} does not match any current prefix vrfs: {nautobot_prefix.vrfs}")

        vrf_id = get_vrf_id(prefix=prefix, vrf_data=vrf_data, hostname=device_hostname)
        if not vrf_id:
            logger.warning(f"Prefix {prefix.prefix} does not have vrfs in Nautobot. VRF({prefix.vrf}) --> DEVICE({device_hostname}) assignment must be created.")
            return

        if not nautobot_prefix.vrf_assignments or len(nautobot_prefix.vrf_assignments) > 1:
            try:
                logger.warning(f"Assigning VRF {prefix.vrf}(id={vrf_id.id}) to prefix {prefix.prefix}(id={nautobot_prefix.id})")
                assignment_response = await nautobot_api.post(
                    path="ipam/vrf-prefix-assignments/",
                    json={"prefix": nautobot_prefix.id, "vrf": vrf_id.id}
                )
                async with lock:
                    prefixes[prefix.prefix].vrf_assignments.append({"id": assignment_response.json().get("id")})
                return
            except Exception as e:
                logger.exception(f"Failed to assign VRF {prefix.vrf} (id={vrf_id.id}) to prefix {prefix.prefix}", exc_info=e)
                return

        if len(nautobot_prefix.vrf_assignments) == 1:
            await nautobot_api.delete(
                path="ipam/vrf-prefix-assignments/",
                json=[{"id": nautobot_prefix.vrf_assignments[0]["id"]}]
            )

            try:
                assignment_response = await nautobot_api.post(
                    path="ipam/vrf-prefix-assignments/",
                    json={"prefix": nautobot_prefix.id, "vrf": vrf_id.id}
                )
                async with lock:
                    prefixes[prefix.prefix].vrf_assignments = [{"id": assignment_response.json().get("id")}]
            except Exception as e:
                logger.exception(f"Failed to re-assign VRF {prefix.vrf} to prefix {prefix.prefix}", exc_info=e)


async def main():

    # gathering data from devices and nautobot
    prefixes, interface_data, vrf_data, prefix2vrf_mappings = await collect_data()

    async with AsyncAPIClient(base_address=settings.NAUTOBOT_HOSTNAME, token=settings.NAUTOBOT_TOKEN) as nautobot_api:

        # lock to avoid race condition in process_prefix_vrf_mapping
        lock = asyncio.Lock()
        # Limit to N concurrent prefix tasks
        semaphore = asyncio.Semaphore(50)

        # creating prefixes and mapping them to vrfs
        prefix_tasks = [
            process_prefix_vrf_mapping(
                prefix=prefix,
                device_hostname=device.hostname,
                prefixes=prefixes,
                vrf_data=vrf_data,
                nautobot_api=nautobot_api,
                lock=lock,
                semaphore=semaphore
            )
            for device in interface_data
            for prefix in device.interfaces
        ]

        await asyncio.gather(*prefix_tasks)

        # removing stale vrf to prefix mappings
        remove_vrf_mapping_tasks = [
            remove_stale_vrf_assignment(prefix, vrf_list, prefixes, nautobot_api)
            for prefix, vrf_list in prefix2vrf_mappings.items()
        ]

        await asyncio.gather(*remove_vrf_mapping_tasks)

if __name__ == "__main__":

    asyncio.run(main())
