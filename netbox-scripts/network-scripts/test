import os
import requests
import urllib3
from concurrent.futures import ThreadPoolExecutor, as_completed

# Отключение InsecureRequestWarning
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# —————————————————————————————————————————————————————————
#  Конфигурация
# —————————————————————————————————————————————————————————
NAUTOBOT_URL   = os.getenv("NAUTOBOT_URL",   "https://s-msk-p-netbox02")
NAUTOBOT_TOKEN = os.getenv("NAUTOBOT_TOKEN", "e1fbfbcdc94dc589c4beea1b837bdce5b19a9763")
IPAM_HOST      = "ipam.raiffeisen.ru"
IPAM_TOKEN     = "p5msyTWUSaSuj-hvOcGb0fjt2nLL-fPt"
IPAM_APP_ID    = "gts"

HEADERS = {
    "Authorization": f"Token {NAUTOBOT_TOKEN}",
    "Content-Type":  "application/json",
    "Accept":        "application/json",
}

# —————————————————————————————————————————————————————————
#  Вспомогательные функции для Nautobot API
# —————————————————————————————————————————————————————————
def get_nautobot_vrfs():
    """Возвращает словарь name→UUID всех VRF в Nautobot."""
    url = f"{NAUTOBOT_URL}/api/ipam/vrfs/?limit=0"
    r = requests.get(url, headers=HEADERS, verify=False); r.raise_for_status()
    return { vrf["name"]: vrf["id"] for vrf in r.json()["results"] }

def get_nautobot_prefix(prefix_cidr):
    """
    Создаёт/обновлять префикс не пытаясь привязать к VRF (M2M отдельным запросом).
    """
    url = f"{NAUTOBOT_URL}/api/ipam/prefixes/"
    params = {"prefix": prefix_cidr}
    r = requests.get(url, headers=HEADERS, params=params, verify=False)
    if not r.ok:
        print(f"[ERROR] fetch Prefix '{prefix_cidr}' failed: {r.status_code}\n{r.text}")
        r.raise_for_status()
    res = r.json().get("results", [])
    return res[0] if res else None

def create_prefix(payload):
    url = f"{NAUTOBOT_URL}/api/ipam/prefixes/"
    r = requests.post(url, headers=HEADERS, json=payload, verify=False)
    if not r.ok:
        print(f"[ERROR] create Prefix '{payload['prefix']}' failed: {r.status_code}\n{r.text}")
        r.raise_for_status()
    return r.json()

def update_prefix(prefix_id, payload):
    url = f"{NAUTOBOT_URL}/api/ipam/prefixes/{prefix_id}/"
    r = requests.patch(url, headers=HEADERS, json=payload, verify=False)
    if not r.ok:
        print(f"[ERROR] update Prefix id={prefix_id} failed: {r.status_code}\n{r.text}")
        r.raise_for_status()
    return r.json()

def get_vrf_prefix_assignment(prefix_id, vrf_id):
    """Проверяет, есть ли уже связь prefix↔vrf в through-таблице."""
    url = f"{NAUTOBOT_URL}/api/ipam/vrf-prefix-assignments/"
    params = {"prefix": prefix_id, "vrf": vrf_id}
    r = requests.get(url, headers=HEADERS, params=params, verify=False)
    if not r.ok:
        print(f"[ERROR] fetch VRF-Prefix assignment failed: {r.status_code}\n{r.text}")
        r.raise_for_status()
    results = r.json().get("results", [])
    return results[0] if results else None

def create_vrf_prefix_assignment(prefix_id, vrf_id):
    """Создаёт связь prefix↔vrf через through-таблицу."""
    url = f"{NAUTOBOT_URL}/api/ipam/vrf-prefix-assignments/"
    body = {"prefix": prefix_id, "vrf": vrf_id}
    r = requests.post(url, headers=HEADERS, json=body, verify=False)
    if not r.ok:
        print(f"[ERROR] create VRF-Prefix assignment failed: {r.status_code}\n{r.text}")
        r.raise_for_status()
    return r.json()

# —————————————————————————————————————————————————————————
#  Основной код
# —————————————————————————————————————————————————————————
if __name__ == "__main__":
    from ipam import IPAM

    # 1) Забираем все VRF из phpIPAM
    ipam = IPAM(hostname=IPAM_HOST, app_id=IPAM_APP_ID, token=IPAM_TOKEN)
    php_vrfs     = ipam.vrf.get().get("data", [])
    php_prefixes = ipam.subnet.get().get("data", [])

    # 2) Строим маппинг phpIPAM vrfId→name и name→Nautobot UUID
    php_vrf_name_map = { v["vrfId"]: v["name"] for v in php_vrfs }
    nautobot_vrfs    = get_nautobot_vrfs()
    vrf_map = {
        pid: nautobot_vrfs.get(name)
        for pid, name in php_vrf_name_map.items()
    }

    def process_prefix(rec):
        cidr = f"{rec['subnet']}/{rec['mask']}"
        php_vrf_id = rec.get("vrfId")
        nb_vrf_id = vrf_map.get(php_vrf_id) if php_vrf_id and php_vrf_id != "0" else None

        # Пропускаем префиксы без VRF
        # if not nb_vrf_id:
        #     #print(f"[SKIP] {cidr} — no VRF assigned")
        #     return

        # Общий payload (без M2M)
        payload = {
            "prefix":      cidr,
            "status": 'Active',
            "description": rec.get("description") or "",
            "is_pool":     rec.get("isPool") == "1",
            "custom_fields": {
                "location": rec.get("location") or "",
                "vra":      rec.get("custom_vRA") == "1",
                "k8s":      rec.get("custom_k8s") == "1",
            },
        }

        # Создание или обновление префикса
        existing = get_nautobot_prefix(cidr)
        if existing:
            prefix_id = existing["id"]
            update_prefix(prefix_id, payload)
            print(f"[OK] Updated {cidr} (id={prefix_id})")
        else:
            new = create_prefix(payload)
            prefix_id = new["id"]
            print(f"[OK] Created {cidr} (id={prefix_id})")

        if nb_vrf_id:
            if not get_vrf_prefix_assignment(prefix_id, nb_vrf_id):
                create_vrf_prefix_assignment(prefix_id, nb_vrf_id)
                print(f"[OK] Assigned {cidr} to VRF {nb_vrf_id}")
        else:
            print(f"[SKIP] No VRF for {cidr}, assignment skipped")

    # 4) Параллельная обработка (10 потоков)
    with ThreadPoolExecutor(max_workers=50) as executor:
        futures = [executor.submit(process_prefix, p) for p in php_prefixes]
        for fut in as_completed(futures):
            try:
                fut.result()
            except Exception as e:
                print(f"[ERROR] Exception: {e}")

    print("All prefixes processed.")
