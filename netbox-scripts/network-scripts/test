import time
import logging
import concurrent.futures

import urllib3
import requests
from decouple import config
from ntc_templates.parse import parse_output
from netmiko import ConnectHandler
import pynautobot
import socket
import re

# Отключаем предупреждения InsecureRequestWarning
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Константы из окружения
HPNA_LOGIN = config('HPNA_LOGIN')
HPNA_PASSWORD = config('HPNA_PASSWORD')
NAUTOBOT_URL = config('NAUTOBOT_URL')
NAUTOBOT_TOKEN = config('NAUTOBOT_TOKEN')

# Логгер
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s'
)
logger = logging.getLogger(__name__)


def netmiko_connect(netbox_device, device_type):
    netmiko_device = {
        'device_type': device_type,
        'host': str(netbox_device.primary_ip4)[:-3:],
        'username': config('HPNA_LOGIN'),
        'password': config('HPNA_PASSWORD'),
        'timeout': 200,
        'port': 22,
        "global_delay_factor": 2,
        'conn_timeout': 200
    }

    try:
        net_connect = ConnectHandler(**netmiko_device)
    except Exception as error:
        try:
            net_connect = ConnectHandler(**netmiko_device)
        except Exception as error:
            logger.error(f"Connection error {netbox_device}")
            return None

    return net_connect


def netbox_connection():
    """
    Возвращает клиент pynautobot с увеличенным пулом соединений.
    """
    api = pynautobot.api(
        NAUTOBOT_URL,
        token=NAUTOBOT_TOKEN,
        verify=False,
    )
    adapter = requests.adapters.HTTPAdapter(
        pool_connections=1000,
        pool_maxsize=1000
    )
    api.http_session.mount('http://', adapter)
    api.http_session.mount('https://', adapter)
    api.http_session.verify = False
    return api


def create_arp_netbox_on_cisco_ios(netbox_device, netbox_api):
    net_connect = netmiko_connect(netbox_device, 'cisco_ios')

    if not net_connect:
        return

    try:
        device_vrfs = netbox_api.ipam.vrfs.filter(device=netbox_device.id)

        existing_vrf_in_device = {vrf.name: vrf.id for vrf in device_vrfs}

        for vrf_name, vrf_id in existing_vrf_in_device.items():
            # if vrf_name == 'vtrec':
            netbox_ip_addresses = netbox_api.ipam.ip_addresses.filter(present_in_vrf_id=vrf_id)
            netbox_device_arp = [netbox_arp.address for netbox_arp in netbox_ip_addresses]
            set_device_arp = set()
            output = net_connect.send_command(f'show ip arp vrf {vrf_name}', read_timeout=200)
            device_arp = parse_output(platform='cisco_ios', command='show ip arp', data=output)

            for mac_nice in device_arp:
                mac_nice['mac'] = mac_nice['mac'].split('.')
                mac_nice['mac'] = ''.join(mac_nice['mac'])
                blocks = [mac_nice['mac'][x:x + 2] for x in range(0, len(mac_nice['mac']), 2)]
                mac_nice['mac'] = '-'.join(blocks)

            for arp_entry in device_arp:
                skip_list = ['192.168.0.0', '192.168.0.1', '192.168.0.2',
                             '192.168.0.3', '192.168.0.4', '192.168.0.5',
                             '192.168.0.6']

                if any(sub in arp_entry['address'] for sub in skip_list):
                    continue
                set_device_arp.add(str(arp_entry['address'] + '/32'))

                if str(arp_entry['mac']).upper() == 'IN-CO-MP-LE-TE':
                    continue

                try:
                    dnsname, alias, addresslist = socket.gethostbyaddr(f'{arp_entry["address"]}')
                    dnsname = re.sub(r'[#*\s\[\]\"]', '', dnsname)
                except Exception as err:
                    dnsname = ''

                if str(arp_entry['address'] + '/32') not in netbox_device_arp:
                    try:
                        netbox_api.ipam.ip_addresses.create([{
                            "address": f"{arp_entry['address']}/32",
                            "custom_fields": {
                                "mac_address": arp_entry['mac']
                            },
                            "dns_name": dnsname,
                            "status": "Active",
                            "namespace": "ed1a3ab7-deea-4872-b111-b44513de94a8"
                        }])
                    except Exception as error:
                        print(arp_entry['address'], dnsname, error, vrf_name, netbox_device, arp_entry)
                        # ip = netbox_api.ipam.ip_addresses.get(address=f"{arp_entry['address']}/32")
                        # prefix_id = ip.parent.id
                        # if len(ip.parent.vrfs) == 0:
                        #     netbox_api.ipam.vrf_prefix_assignments.create(prefix=prefix_id,
                        #                                                   vrf=vrf_id)
                        # elif len(ip.parent.vrfs) == 1:
                        #     vrfs_in_pref = netbox_api.ipam.vrf_prefix_assignments.get(prefix=prefix_id)
                        #     vrfs_in_pref.delete()
                        #     netbox_api.ipam.vrf_prefix_assignments.create(prefix=prefix_id,
                        #                                                   vrf=vrf_id)

                        # t = netbox_api.ipam.vrf_prefix_assignments.get(prefix=ip.parent.prefix)
                        # try:
                        #     t.delete()
                        # except:
                        #     print(ip, ip.parent.prefix)
                        # netbox_api.ipam.vrf_prefix_assignments.create(prefix=prefix_id,
                        #                                               vrf=vrf_id)
                        # netbox_api.ipam.ip_addresses.create([{
                        #     "address": f"{arp_entry['address']}/32",
                        #     "custom_fields": {
                        #         "mac_address": arp_entry['mac']
                        #     },
                        #     "dns_name": dnsname,
                        #     "status": "Active",
                        #     "namespace": "ed1a3ab7-deea-4872-b111-b44513de94a8"
                        # }])
        net_connect.disconnect()
        logger.info(f'END SCRIPT {netbox_device}')
    except Exception as error:
        logger.error(F'ERROR SCRIPT {netbox_device} - {error}')


def create_arp_netbox_on_cisco_nxos(netbox_device, netbox_api):
    net_connect = netmiko_connect(netbox_device, 'cisco_nxos')

    if not net_connect:
        return

    try:
        device_vrfs = netbox_api.ipam.vrfs.filter(device=netbox_device.id)

        existing_vrf_in_device = {vrf.name: vrf.id for vrf in device_vrfs}

        for vrf_name, vrf_id in existing_vrf_in_device.items():
            netbox_ip_addresses = netbox_api.ipam.ip_addresses.filter(present_in_vrf_id=vrf_id)
            netbox_device_arp = [netbox_arp.address for netbox_arp in netbox_ip_addresses]
            set_device_arp = set()

            output = net_connect.send_command(f'show ip arp vrf {vrf_name}', read_timeout=200)
            device_arp = parse_output(platform='cisco_nxos', command='show ip arp', data=output)

            for mac_nice in device_arp:
                mac_nice['mac'] = mac_nice['mac'].split('.')
                mac_nice['mac'] = ''.join(mac_nice['mac'])
                blocks = [mac_nice['mac'][x:x + 2] for x in range(0, len(mac_nice['mac']), 2)]
                mac_nice['mac'] = '-'.join(blocks)

            for arp_entry in device_arp:
                set_device_arp.add(str(arp_entry['address'] + '/32'))

                if str(arp_entry['mac']).upper() == 'IN-CO-MP-LE-TE':
                    continue

                try:
                    dnsname, alias, addresslist = socket.gethostbyaddr(f'{arp_entry["address"]}')
                    dns = dnsname.replace('#', '')
                    dnsname = dns.replace('*', '')
                except Exception as err:
                    dnsname = ''

                if str(arp_entry['address'] + '/32') not in netbox_device_arp:
                    try:
                        netbox_api.ipam.ip_addresses.create([{
                            "address": f"{arp_entry['address']}/32",
                            "custom_fields": {
                                "mac_address": arp_entry['mac']
                            },
                            "dns_name": dnsname,
                            "status": "Active",
                            "namespace": "ed1a3ab7-deea-4872-b111-b44513de94a8"
                        }])
                    except Exception as error:
                        print(arp_entry['address'], dnsname, error, vrf_name, netbox_device, arp_entry)
                        # ip = netbox_api.ipam.ip_addresses.get(address=f"{arp_entry['address']}/32")
                        # prefix_id = ip.parent.id
                        # if len(ip.parent.vrfs) == 0:
                        #     netbox_api.ipam.vrf_prefix_assignments.create(prefix=prefix_id,
                        #                                                   vrf=vrf_id)
                        # elif len(ip.parent.vrfs) == 1:
                        #     vrfs_in_pref = netbox_api.ipam.vrf_prefix_assignments.get(prefix=prefix_id)
                        #     vrfs_in_pref.delete()
                        #     netbox_api.ipam.vrf_prefix_assignments.create(prefix=prefix_id,
                        #                                                   vrf=vrf_id)

                        # ip = netbox_api.ipam.ip_addresses.get(address=f"{arp_entry['address']}/32")
                        # prefix_id = ip.parent.id
                        # t = netbox_api.ipam.vrf_prefix_assignments.get(prefix=ip.parent.prefix)
                        # try:
                        #     t.delete()
                        # except:
                        #     print(ip, ip.parent.prefix)
                        # netbox_api.ipam.vrf_prefix_assignments.create(prefix=prefix_id,
                        #                                               vrf=vrf_id)
                        # netbox_api.ipam.ip_addresses.create([{
                        #     "address": f"{arp_entry['address']}/32",
                        #     "custom_fields": {
                        #         "mac_address": arp_entry['mac']
                        #     },
                        #     "dns_name": dnsname,
                        #     "status": "Active",
                        #     "namespace": "ed1a3ab7-deea-4872-b111-b44513de94a8"
                        # }])
        net_connect.disconnect()
        logger.info(f'END SCRIPT {netbox_device}')
    except Exception as error:
        logger.error(F'ERROR SCRIPT {netbox_device} - {error}')


def add_arp_entry_to_netbox():
    start_time = time.time()
    api = netbox_connection()

    # Строим мапу тегов
    all_tags = list(api.extras.tags.all())
    tag_map = {t.id: t.name for t in all_tags}

    # Фильтруем нужные устройства
    devices = list(api.dcim.devices.all())
    targets = []
    for dev in devices:
        names = [tag_map.get(t.id) for t in (dev.tags or [])]
        if 'raif_scripts' in names:
            # if 'scope_BRANCH' in names:
            #     continue
            # else:
            targets.append(dev)

    with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
        for netbox_device in targets:
            #if netbox_device.name == 'MS-VRN00-03':
            # create_arp_netbox_on_cisco_ios(netbox_device, api)
            if netbox_device.platform.name == 'Cisco NXOS':
                #create_arp_netbox_on_cisco_nxos(netbox_device, api)
                executor.submit(
                    create_arp_netbox_on_cisco_nxos,
                    netbox_device,
                    api,
                )
                if netbox_device.platform.name == 'Cisco IOS':
                   #create_arp_netbox_on_cisco_ios(netbox_device, api)
                    executor.submit(
                        create_arp_netbox_on_cisco_ios,
                        netbox_device,
                        api,
                    )

    print("--- %s seconds ---" % (time.time() - start_time))


if __name__ == "__main__":
    add_arp_entry_to_netbox()
