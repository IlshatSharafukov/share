import re
import urllib3
from hpnapy import NAInterface
from openpyxl import Workbook
from openpyxl.worksheet.datavalidation import DataValidation
from openpyxl.styles import PatternFill
from openpyxl.formatting.rule import CellIsRule

# Отключаем предупреждения о самоподписанных сертификатах
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def hpna_connection():
    """Создаёт и возвращает сессию HPNA."""
    print("Connecting to HPNA…")
    api = NAInterface("https://hpna.raiffeisen.ru", ssl_verify=False)
    api.login('ruasfih', 'Lysa142yfdwzfi@')
    print("Connected")
    return api


def fetch_devices():
    """Забирает список устройств и сразу его сортирует по hostName."""
    devices = hpna_connection().list_device()
    print(f"Fetched {len(devices)} devices")
    # Сортируем по имени, без учёта регистра
    devices_sorted = sorted(devices, key=lambda d: d.hostName.lower())
    print("Devices sorted by name")
    return devices_sorted


def clean_name(name: str) -> str:
    """Удаляет суффикс .net.pri (в любом регистре) и переводит в верхний регистр."""
    # Убираем суффиксы .net.pri или .NET.PRI (вариативно)
    cleaned = re.sub(r"\.net\.pri$", "", name, flags=re.IGNORECASE)
    return cleaned.upper()


def export_to_excel(devices, filename="devices.xlsx"):
    """Записывает отсортированный и очищенный список в Excel с выпадающими списками и подсветкой."""
    print(f"Creating Excel file '{filename}'…")
    wb = Workbook()
    ws = wb.active
    ws.title = "Devices"

    # Заголовки
    ws.append(["Device Name", "Scope", "Subscope"])

    # Запись очищенных устройств в столбец A
    for dev in devices:
        name = clean_name(dev.hostName)
        ws.append([name, "", ""])

    max_row = len(devices) + 1

    # Опции для выпадающих списков
    options = [
        "OTV", "PROD D8", "PROD 70", "PROD 34", "DTV",
        "PROD X5", "EJP (VPN)", "iDMZ", "PCI-DCI", "PCI-D8",
        "PCI-X5", "PCI-70", "MSK60", "MSK34", "BRANCH", "OOB"
    ]
    formula = f'"{",".join(options)}"'

    # Настраиваем валидацию для столбцов B и C
    dv = DataValidation(type="list", formula1=formula, allow_blank=True)
    dv.add(f'B2:B{max_row}')
    dv.add(f'C2:C{max_row}')
    ws.add_data_validation(dv)

    # Карта цветов для conditional formatting
    color_map = {
        "OTV":      "FFFFC7CE",
        "PROD D8":  "FFC6EFCE",
        "PROD 70":  "FFEBF1DE",
        "PROD 34":  "FFBDD7EE",
        "DTV":      "FFFDE9D9",
        "PROD X5":  "FFF2DCDB",
        "EJP (VPN)": "FFE4DFEC",
        "iDMZ":     "FFFFF2CC",
        "PCI-DCI":  "FFDDEBF7",
        "PCI-D8":   "FFFCE4D6",
        "PCI-X5":   "FFD9EAD3",
        "PCI-70":   "FFF4DFBA",
        "MSK60":    "FFE4F0FB",
        "MSK34":    "FFE8EEDB",
        "BRANCH":   "FFEDEDED",
        "OOB":      "FFEFE7F6",
    }

    # Применяем условное форматирование для каждого значения
    for col in ("B", "C"):
        for val, col_code in color_map.items():
            fill = PatternFill(start_color=col_code, end_color=col_code, fill_type="solid")
            rule = CellIsRule(
                operator="equal",
                formula=[f'"{val}"'],
                stopIfTrue=True,
                fill=fill
            )
            ws.conditional_formatting.add(f"{col}2:{col}{max_row}", rule)

    wb.save(filename)
    print(f"Excel '{filename}' saved — записано {len(devices)} устройств.")


def main():
    devices = fetch_devices()
    export_to_excel(devices)

if __name__ == "__main__":
    main()
