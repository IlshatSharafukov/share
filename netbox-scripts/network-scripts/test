import pynetbox
import requests
from netmiko import ConnectHandler
from netmiko.exceptions import NetMikoTimeoutException, NetMikoAuthenticationException
from decouple import config
import urllib3
import logging
import concurrent.futures
import time

# Отключаем предупреждения SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Настройка логирования
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger()


def netbox_connection():
    """Подключение к NetBox API"""
    netbox_api = pynetbox.api(
        config('NETBOX_URL'),
        token=config('NETBOX_TOKEN'),
        threading=True
    )
    adapter = requests.adapters.HTTPAdapter(pool_connections=100, pool_maxsize=100)
    netbox_api.http_session.mount('http://', adapter)
    netbox_api.http_session.mount('https://', adapter)
    netbox_api.http_session.verify = False
    return netbox_api


def get_device_type(platform_name):
    """Определение типа устройства для netmiko"""
    platform_mapping = {
        'Cisco IOS': 'cisco_ios',
        'Cisco NXOS': 'cisco_nxos',
        'Huawei Versatile Routing Platform': 'huawei_vrp',
        'Ruijie RG': 'cisco_ios'
    }
    return platform_mapping.get(platform_name, 'cisco_ios')


def test_ssh_connection(device):
    """Тестирование SSH соединения с устройством"""
    device_name = device.name
    
    # Проверяем наличие IP адреса
    if not device.primary_ip:
        error_info = {
            'device': device_name,
            'ip': 'НЕТ IP',
            'platform': device.platform.name if device.platform else 'Unknown',
            'error': 'Отсутствует primary IP адрес',
            'error_type': 'NO_IP'
        }
        return False, error_info
    
    # Получаем IP без маски
    host_ip = str(device.primary_ip).split('/')[0]
    
    # Определяем тип устройства
    device_type = get_device_type(device.platform.name if device.platform else 'Unknown')
    
    # Параметры подключения
    connection_params = {
        'device_type': device_type,
        'host': host_ip,
        'username': config('HPNA_LOGIN'),
        'password': config('HPNA_PASSWORD'),
        'timeout': 30,
        'conn_timeout': 30,
        'port': 22,
        'global_delay_factor': 1
    }
    
    try:
        # Устанавливаем SSH соединение
        net_connect = ConnectHandler(**connection_params)
        
        # Простая проверка - отправляем команду
        output = net_connect.send_command('show version', read_timeout=10)
        
        # Закрываем соединение
        net_connect.disconnect()
        
        return True, None
        
    except NetMikoTimeoutException:
        error_info = {
            'device': device_name,
            'ip': host_ip,
            'platform': device.platform.name if device.platform else 'Unknown',
            'error': 'Таймаут подключения (устройство недоступно)',
            'error_type': 'TIMEOUT'
        }
        return False, error_info
        
    except NetMikoAuthenticationException:
        error_info = {
            'device': device_name,
            'ip': host_ip,
            'platform': device.platform.name if device.platform else 'Unknown',
            'error': 'Ошибка аутентификации (неверный логин/пароль)',
            'error_type': 'AUTH_ERROR'
        }
        return False, error_info
        
    except Exception as e:
        error_info = {
            'device': device_name,
            'ip': host_ip,
            'platform': device.platform.name if device.platform else 'Unknown',
            'error': f'Другая ошибка: {str(e)}',
            'error_type': 'OTHER_ERROR'
        }
        return False, error_info


def test_single_device(device_name):
    """Тестирование SSH соединения для одного устройства"""
    netbox_api = netbox_connection()
    device = netbox_api.dcim.devices.get(name=device_name.upper())
    
    if not device:
        print(f"Устройство {device_name} не найдено в NetBox")
        return
    
    result, error_info = test_ssh_connection(device)
    
    if result:
        print(f"✅ {device_name}: SSH соединение успешно")
    else:
        print(f"❌ {device_name}: {error_info['error']}")
        print(f"   IP: {error_info['ip']}")
        print(f"   Платформа: {error_info['platform']}")
        print(f"   Тип ошибки: {error_info['error_type']}")


def test_all_devices():
    """Тестирование SSH соединений для всех устройств с тегом raif_scripts"""
    start_time = time.time()
    
    netbox_api = netbox_connection()
    
    # Получаем все устройства с тегом raif_scripts
    all_devices = netbox_api.dcim.devices.all()
    script_devices = []
    
    for device in all_devices:
        device_tags = str(device.tags)
        if 'raif_scripts' in device_tags:
            script_devices.append(device)
    
    logger.info(f"Найдено {len(script_devices)} устройств для тестирования")
    
    successful_connections = 0
    failed_connections = []
    
    # Параллельное тестирование с ограничением потоков
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        # Отправляем задачи на выполнение
        future_to_device = {executor.submit(test_ssh_connection, device): device for device in script_devices}
        
        # Обрабатываем результаты
        for future in concurrent.futures.as_completed(future_to_device):
            device = future_to_device[future]
            try:
                result, error_info = future.result()
                if result:
                    successful_connections += 1
                else:
                    failed_connections.append(error_info)
            except Exception as exc:
                error_info = {
                    'device': device.name,
                    'ip': str(device.primary_ip).split('/')[0] if device.primary_ip else 'НЕТ IP',
                    'platform': device.platform.name if device.platform else 'Unknown',
                    'error': f'Исключение при выполнении: {exc}',
                    'error_type': 'EXCEPTION'
                }
                failed_connections.append(error_info)
    
    # Детальная статистика по ошибкам
    total_time = time.time() - start_time
    
    print(f"\n{'='*80}")
    print(f"АНАЛИЗ НЕУДАЧНЫХ SSH ПОДКЛЮЧЕНИЙ")
    print(f"{'='*80}")
    print(f"Всего устройств: {len(script_devices)}")
    print(f"Успешных подключений: {successful_connections}")
    print(f"Неудачных подключений: {len(failed_connections)}")
    print(f"Время выполнения: {total_time:.2f} секунд")
    
    if failed_connections:
        print(f"\n{'='*80}")
        print(f"ДЕТАЛЬНЫЙ АНАЛИЗ ОШИБОК:")
        print(f"{'='*80}")
        
        # Группировка по типам ошибок
        error_types = {}
        for error in failed_connections:
            error_type = error['error_type']
            if error_type not in error_types:
                error_types[error_type] = []
            error_types[error_type].append(error)
        
        # Вывод статистики по типам ошибок
        for error_type, errors in error_types.items():
            print(f"\n{error_type}: {len(errors)} устройств")
            print("-" * 60)
            
            for error in errors:
                print(f"  Устройство: {error['device']}")
                print(f"  IP: {error['ip']}")
                print(f"  Платформа: {error['platform']}")
                print(f"  Ошибка: {error['error']}")
                print()
        
        # Группировка по платформам
        print(f"\n{'='*80}")
        print(f"СТАТИСТИКА ОШИБОК ПО ПЛАТФОРМАМ:")
        print(f"{'='*80}")
        
        platform_stats = {}
        for error in failed_connections:
            platform = error['platform']
            if platform not in platform_stats:
                platform_stats[platform] = {'total': 0, 'timeout': 0, 'auth': 0, 'other': 0}
            
            platform_stats[platform]['total'] += 1
            
            if error['error_type'] == 'TIMEOUT':
                platform_stats[platform]['timeout'] += 1
            elif error['error_type'] == 'AUTH_ERROR':
                platform_stats[platform]['auth'] += 1
            else:
                platform_stats[platform]['other'] += 1
        
        for platform, stats in platform_stats.items():
            print(f"\n{platform}:")
            print(f"  Всего ошибок: {stats['total']}")
            print(f"  Таймауты: {stats['timeout']}")
            print(f"  Ошибки аутентификации: {stats['auth']}")
            print(f"  Другие ошибки: {stats['other']}")
    
    print(f"\n{'='*80}")
    
    # Сохранение в файл для дальнейшего анализа
    if failed_connections:
        with open('failed_ssh_connections.txt', 'w', encoding='utf-8') as f:
            f.write("СПИСОК УСТРОЙСТВ С ОШИБКАМИ SSH ПОДКЛЮЧЕНИЯ\n")
            f.write("=" * 80 + "\n\n")
            
            for error in failed_connections:
                f.write(f"Устройство: {error['device']}\n")
                f.write(f"IP: {error['ip']}\n")
                f.write(f"Платформа: {error['platform']}\n")
                f.write(f"Тип ошибки: {error['error_type']}\n")
                f.write(f"Ошибка: {error['error']}\n")
                f.write("-" * 40 + "\n\n")
        
        print(f"Детальный список ошибок сохранен в файл: failed_ssh_connections.txt")


if __name__ == "__main__":
    # Тестирование всех устройств
    test_all_devices()
    
    # Или тестирование одного устройства (раскомментируйте строку ниже)
    # test_single_device("DEVICE_NAME")
