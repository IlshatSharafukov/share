import pynetbox
import requests
from netmiko import ConnectHandler
from netmiko.exceptions import NetMikoTimeoutException, NetMikoAuthenticationException
from decouple import config
import urllib3
import logging
import concurrent.futures
import time

# Отключаем предупреждения SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Настройка логирования
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger()


def netbox_connection():
    """Подключение к NetBox API"""
    netbox_api = pynetbox.api(
        config('NETBOX_URL'),
        token=config('NETBOX_TOKEN'),
        threading=True
    )
    adapter = requests.adapters.HTTPAdapter(pool_connections=100, pool_maxsize=100)
    netbox_api.http_session.mount('http://', adapter)
    netbox_api.http_session.mount('https://', adapter)
    netbox_api.http_session.verify = False
    return netbox_api


def get_device_type(platform_name):
    """Определение типа устройства для netmiko"""
    platform_mapping = {
        'Cisco IOS': 'cisco_ios',
        'Cisco NXOS': 'cisco_nxos',
        'Huawei Versatile Routing Platform': 'huawei_vrp',
        'Ruijie RG': 'cisco_ios'
    }
    return platform_mapping.get(platform_name, 'cisco_ios')


def test_ssh_connection(device):
    """Тестирование SSH соединения с устройством"""
    device_name = device.name
    
    # Проверяем наличие IP адреса
    if not device.primary_ip:
        logger.error(f"{device_name}: Отсутствует primary IP адрес")
        return False
    
    # Получаем IP без маски
    host_ip = str(device.primary_ip).split('/')[0]
    
    # Определяем тип устройства
    device_type = get_device_type(device.platform.name if device.platform else 'Unknown')
    
    # Параметры подключения
    connection_params = {
        'device_type': device_type,
        'host': host_ip,
        'username': config('HPNA_LOGIN'),
        'password': config('HPNA_PASSWORD'),
        'timeout': 30,
        'conn_timeout': 30,
        'port': 22,
        'global_delay_factor': 1
    }
    
    try:
        logger.info(f"{device_name} ({host_ip}): Попытка подключения...")
        
        # Устанавливаем SSH соединение
        net_connect = ConnectHandler(**connection_params)
        
        # Простая проверка - отправляем команду
        output = net_connect.send_command('show version', read_timeout=10)
        
        # Закрываем соединение
        net_connect.disconnect()
        
        logger.info(f"✅ {device_name} ({host_ip}): SSH соединение успешно")
        return True
        
    except NetMikoTimeoutException:
        logger.error(f"❌ {device_name} ({host_ip}): Таймаут подключения")
        return False
        
    except NetMikoAuthenticationException:
        logger.error(f"❌ {device_name} ({host_ip}): Ошибка аутентификации")
        return False
        
    except Exception as e:
        logger.error(f"❌ {device_name} ({host_ip}): Ошибка подключения - {str(e)}")
        return False


def test_single_device(device_name):
    """Тестирование SSH соединения для одного устройства"""
    netbox_api = netbox_connection()
    device = netbox_api.dcim.devices.get(name=device_name.upper())
    
    if not device:
        logger.error(f"Устройство {device_name} не найдено в NetBox")
        return
    
    test_ssh_connection(device)


def test_all_devices():
    """Тестирование SSH соединений для всех устройств с тегом raif_scripts"""
    start_time = time.time()
    
    netbox_api = netbox_connection()
    
    # Получаем все устройства с тегом raif_scripts
    all_devices = netbox_api.dcim.devices.all()
    script_devices = []
    
    for device in all_devices:
        device_tags = str(device.tags)
        if 'raif_scripts' in device_tags:
            script_devices.append(device)
    
    logger.info(f"Найдено {len(script_devices)} устройств для тестирования")
    
    successful_connections = 0
    failed_connections = 0
    
    # Параллельное тестирование с ограничением потоков
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        # Отправляем задачи на выполнение
        future_to_device = {executor.submit(test_ssh_connection, device): device for device in script_devices}
        
        # Обрабатываем результаты
        for future in concurrent.futures.as_completed(future_to_device):
            device = future_to_device[future]
            try:
                result = future.result()
                if result:
                    successful_connections += 1
                else:
                    failed_connections += 1
            except Exception as exc:
                logger.error(f"❌ {device.name}: Исключение при выполнении - {exc}")
                failed_connections += 1
    
    # Статистика
    total_time = time.time() - start_time
    logger.info(f"\n{'='*60}")
    logger.info(f"СТАТИСТИКА ТЕСТИРОВАНИЯ SSH СОЕДИНЕНИЙ")
    logger.info(f"{'='*60}")
    logger.info(f"Всего устройств: {len(script_devices)}")
    logger.info(f"Успешных подключений: {successful_connections}")
    logger.info(f"Неудачных подключений: {failed_connections}")
    logger.info(f"Время выполнения: {total_time:.2f} секунд")
    logger.info(f"{'='*60}")


if __name__ == "__main__":
    # Тестирование всех устройств
    test_all_devices()
    
    # Или тестирование одного устройства (раскомментируйте строку ниже)
    # test_single_device("DEVICE_NAME")
