import logging
import requests
import pynautobot
from decouple import config

# Константы из окружения
NAUTOBOT_URL = config('NAUTOBOT_URL')
NAUTOBOT_TOKEN = config('NAUTOBOT_TOKEN')

# Логгер
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s %(levelname)s %(message)s'
)
logger = logging.getLogger(__name__)


def get_nautobot_api():
    """Возвращает клиент pynautobot."""
    api = pynautobot.api(
        NAUTOBOT_URL,
        token=NAUTOBOT_TOKEN,
        verify=False,
    )
    adapter = requests.adapters.HTTPAdapter(
        pool_connections=100,
        pool_maxsize=100
    )
    api.http_session.mount('http://', adapter)
    api.http_session.mount('https://', adapter)
    api.http_session.verify = False
    return api


def cleanup_unused_vlans():
    """
    Удаляет VLAN которые не имеют связей с устройствами.
    """
    api = get_nautobot_api()
    
    # Получаем все VLAN
    logger.info('Получение списка всех VLAN...')
    all_vlans = list(api.ipam.vlans.all())
    logger.info(f'Найдено VLAN: {len(all_vlans)}')
    
    # Получаем связи пачками для ускорения
    logger.info('Получение связей device-vlan...')
    linked_vlan_ids = set()
    
    # Используем пагинацию с большим размером страницы
    page_size = 1000
    offset = 0
    
    while True:
        relations_page = api.extras.relationship_associations.filter(
            relationship='devices_vlans',
            limit=page_size,
            offset=offset
        )
        
        if not relations_page:
            break
            
        # Добавляем ID из текущей страницы
        page_vlan_ids = {rel.source_id for rel in relations_page}
        linked_vlan_ids.update(page_vlan_ids)
        
        logger.info(f'Обработано связей: {offset + len(relations_page)}')
        
        # Если страница неполная - это последняя
        if len(relations_page) < page_size:
            break
            
        offset += page_size
    
    logger.info(f'VLAN связанных с устройствами: {len(linked_vlan_ids)}')
    
    # Находим VLAN без связей
    vlans_to_delete = []
    for vlan in all_vlans:
        if vlan.id not in linked_vlan_ids:
            vlans_to_delete.append(vlan)
    
    logger.info(f'VLAN для удаления: {len(vlans_to_delete)}')
    
    # Удаляем неиспользуемые VLAN пачками
    deleted_count = 0
    batch_size = 50
    
    for i in range(0, len(vlans_to_delete), batch_size):
        batch = vlans_to_delete[i:i + batch_size]
        for vlan in batch:
            try:
                logger.info(f'Удаление VLAN {vlan.vid} ({vlan.name}) ID: {vlan.id}')
                vlan.delete()
                deleted_count += 1
            except Exception as e:
                logger.error(f'Ошибка удаления VLAN {vlan.vid}: {e}')
        
        logger.info(f'Обработано пачек удаления: {(i // batch_size) + 1}')
    
    logger.info(f'Успешно удалено VLAN: {deleted_count}')


def main():
    """Основная функция."""
    logger.info('Запуск очистки неиспользуемых VLAN')
    cleanup_unused_vlans()
    logger.info('Очистка завершена')


if __name__ == '__main__':
    main()
