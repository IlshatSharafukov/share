import time
import logging
import concurrent.futures
import re
import socket
from datetime import datetime

import urllib3
import requests
from decouple import config
from ntc_templates.parse import parse_output
from netmiko import ConnectHandler
import pynautobot

# Отключаем предупреждения InsecureRequestWarning
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Константы из окружения
HPNA_LOGIN = config('HPNA_LOGIN')
HPNA_PASSWORD = config('HPNA_PASSWORD')
NAUTOBOT_URL = config('NAUTOBOT_URL')
NAUTOBOT_TOKEN = config('NAUTOBOT_TOKEN')

# Логгер
logging.basicConfig(level=logging.WARNING, format='%(asctime)s %(levelname)s %(message)s')
logger = logging.getLogger(__name__)


def netmiko_connect_with_retry(nautobot_device, device_type, max_retries=3):
    """Создает подключение к сетевому устройству через Netmiko с retry логикой."""
    for attempt in range(max_retries):
        try:
            netmiko_device = {
                'device_type': device_type,
                'host': str(nautobot_device.primary_ip4)[:-3:],
                'username': HPNA_LOGIN,
                'password': HPNA_PASSWORD,
                'timeout': 300,
                'port': 22,
                "global_delay_factor": 3,
                'conn_timeout': 300,
                'blocking_timeout': 20,
                'keepalive': 30
            }
            return ConnectHandler(**netmiko_device)
        except Exception as error:
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)
                continue
            else:
                logger.error(f'Connection error {nautobot_device}')
                return None
    return None


def send_command_safe(connection, command, timeout=300):
    """Безопасная отправка команды с обработкой pattern detection проблем."""
    try:
        return connection.send_command(command, read_timeout=timeout)
    except Exception as error:
        if "pattern not detected" in str(error).lower():
            try:
                return connection.send_command(command, read_timeout=timeout * 2)
            except Exception:
                raise error
        else:
            raise error


def nautobot_connection():
    """Возвращает клиент pynautobot с увеличенным пулом соединений."""
    api = pynautobot.api(NAUTOBOT_URL, token=NAUTOBOT_TOKEN, verify=False)
    adapter = requests.adapters.HTTPAdapter(pool_connections=1000, pool_maxsize=1000)
    api.http_session.mount('http://', adapter)
    api.http_session.mount('https://', adapter)
    api.http_session.verify = False
    return api


def format_mac_address(mac_address):
    """Преобразует MAC-адрес в формат aa-bb-cc-dd-ee-ff."""
    mac_parts = mac_address.split('.')
    mac_joined = ''.join(mac_parts)
    blocks = [mac_joined[x:x + 2] for x in range(0, len(mac_joined), 2)]
    return '-'.join(blocks)


def get_dns_name(ip_address):
    """Получает DNS имя для IP-адреса."""
    try:
        dns_name, alias, address_list = socket.gethostbyaddr(ip_address)
        return re.sub(r'[#*\s\[\]\"]', '', dns_name)
    except Exception:
        return ''


def get_current_timestamp():
    """Возвращает текущую дату и время в формате 2025-07-01 15:30:45."""
    return datetime.now().strftime('%Y-%m-%d %H:%M:%S')


def get_discovered_tag(nautobot_api):
    """Получает тег discovered_from_device."""
    try:
        tag = nautobot_api.extras.tags.get(name='discovered_from_device')
        return tag.id if tag else None
    except Exception:
        return None


def parse_ilo_arp_output(output):
    """Парсит ARP вывод для iLO и других нестандартных устройств."""
    arp_entries = []
    lines = output.strip().split('\n')

    for line in lines:
        if any(skip_word in line.lower() for skip_word in [
            'protocol', 'address', 'age', 'hardware', 'type', 'interface',
            'total number', 'static:', 'dynamic:', 'trust:', 'load for', 'time source'
        ]):
            continue

        match = re.match(r'^(\S+)\s+(\d+\.\d+\.\d+\.\d+)\s+(\S+)\s+([0-9a-fA-F.]+)\s+(\S+)(?:\s+(.*))?', line.strip())
        if match:
            protocol, address, age, mac, type_field, interface = match.groups()
            arp_entry = {
                'protocol': protocol,
                'address': address,
                'age': age,
                'mac': mac,
                'type': type_field,
                'interface': interface.strip() if interface else ''
            }
            arp_entries.append(arp_entry)

    return arp_entries


def is_empty_arp_table(output):
    """Проверяет, является ли ARP таблица пустой."""
    output_lower = output.lower()
    empty_indicators = [
        'total number of entries: 0',
        'no entries found',
        'arp table is empty',
        'total entries: 0',
        '0 entries',
        'no arp entries'
    ]
    return any(indicator in output_lower for indicator in empty_indicators)


def load_all_ips_cache(nautobot_api):
    """Загружает все IP-адреса из Nautobot в кэш для быстрого поиска."""
    logger.info('Loading all IP addresses from Nautobot...')
    
    all_ips = {}
    page_size = 3000
    offset = 0
    
    while True:
        try:
            ips_page = nautobot_api.ipam.ip_addresses.filter(limit=page_size, offset=offset)
            if not ips_page:
                break
                
            for ip in ips_page:
                all_ips[ip.address] = ip
            
            logger.info(f'Loaded {len(all_ips)} IPs so far...')
            
            if len(ips_page) < page_size:
                break
                
            offset += page_size
            
        except Exception as error:
            logger.error(f'Error loading IPs at offset {offset}: {error}')
            break
    
    logger.info(f'Finished loading {len(all_ips)} IP addresses into cache')
    return all_ips


def process_ips_batch(nautobot_api, arp_entries, device_name, discovered_tag_id, all_ips_cache, vrf_description="VRF GLOBAL"):
    """Массово обрабатывает IP-адреса: обновляет существующие и создает новые."""
    if not arp_entries:
        return
    
    current_time = get_current_timestamp()
    to_create = []
    to_update = []
    
    # Используем кэш для разделения на обновления и создания
    for arp_entry in arp_entries:
        ip_address = f"{arp_entry['address']}/32"
        
        if ip_address in all_ips_cache:
            # IP существует - готовим обновление
            existing_ip = all_ips_cache[ip_address]
            # Проверяем что это объект Nautobot, а не словарь
            if hasattr(existing_ip, 'id'):
                update_data = {
                    'id': existing_ip.id,
                    'custom_fields': {
                        'mac_address': arp_entry['mac'],
                        'last_update': current_time
                    },
                    'dns_name': arp_entry['dns_name']
                }
                
                # Добавляем тег если его нет
                if discovered_tag_id:
                    current_tags = [tag.id for tag in existing_ip.tags or []]
                    if discovered_tag_id not in current_tags:
                        current_tags.append(discovered_tag_id)
                        update_data['tags'] = current_tags
                
                to_update.append(update_data)
            else:
                # Объект в кэше поврежден, пропускаем
                logger.warning(f"Invalid object in cache for IP {ip_address}")
                continue
        else:
            # IP не существует - проверяем дополнительно в API перед созданием
            try:
                existing_ip = nautobot_api.ipam.ip_addresses.get(address=ip_address)
                if existing_ip:
                    # IP найден в API, но не был в кэше - добавляем в кэш и обновляем
                    all_ips_cache[ip_address] = existing_ip
                    update_data = {
                        'id': existing_ip.id,
                        'custom_fields': {
                            'mac_address': arp_entry['mac'],
                            'last_update': current_time
                        },
                        'dns_name': arp_entry['dns_name']
                    }
                    
                    if discovered_tag_id:
                        current_tags = [tag.id for tag in existing_ip.tags or []]
                        if discovered_tag_id not in current_tags:
                            current_tags.append(discovered_tag_id)
                            update_data['tags'] = current_tags
                    
                    to_update.append(update_data)
                    continue
            except Exception:
                # IP действительно не существует
                pass
            
            # Готовим создание нового IP
            create_data = {
                "address": ip_address,
                "custom_fields": {
                    "mac_address": arp_entry['mac'],
                    "last_update": current_time
                },
                "dns_name": arp_entry['dns_name'],
                "description": vrf_description,
                "status": "Active",
                "namespace": "ed1a3ab7-deea-4872-b111-b44513de94a8"
            }
            
            if discovered_tag_id:
                create_data['tags'] = [discovered_tag_id]
            
            to_create.append(create_data)
    
    # Выполняем массовые операции с retry логикой
    if to_create:
        for attempt in range(3):
            try:
                created_ips = nautobot_api.ipam.ip_addresses.create(to_create)
                logger.info(f"Created {len(to_create)} IPs for device {device_name}")
                # Добавляем созданные IP в кэш
                if isinstance(created_ips, list):
                    for created_ip in created_ips:
                        if hasattr(created_ip, 'address'):
                            all_ips_cache[created_ip.address] = created_ip
                break
            except Exception as error:
                if "already exists" in str(error).lower():
                    # IP уже существуют - это race condition, игнорируем
                    logger.info(f"IPs already exist for device {device_name} (race condition)")
                    break
                elif attempt < 2:
                    logger.warning(f"Attempt {attempt + 1} failed for creating IPs, retrying: {error}")
                    time.sleep(2 ** attempt)
                else:
                    logger.error(f"Error creating IPs for device {device_name}: {error}")
    
    if to_update:
        for attempt in range(3):
            try:
                nautobot_api.ipam.ip_addresses.update(to_update)
                logger.info(f"Updated {len(to_update)} IPs for device {device_name}")
                break
            except Exception as error:
                if attempt < 2:
                    logger.warning(f"Attempt {attempt + 1} failed for updating IPs, retrying: {error}")
                    time.sleep(2 ** attempt)
                else:
                    logger.error(f"Error updating IPs for device {device_name}: {error}")


def get_and_process_arp_table(net_connect, nautobot_device, nautobot_api, platform, discovered_tag_id, all_ips_cache, command, vrf_description):
    """Универсальная функция для получения и обработки ARP таблицы."""
    try:
        output = send_command_safe(net_connect, command)
        
        if is_empty_arp_table(output) or len(output) == 0:
            return

        # Пытаемся распарсить вывод
        device_arp = None
        try:
            device_arp = parse_output(platform=platform, command='show ip arp', data=output)
            if not device_arp:
                raise Exception("Standard parser returned empty result")
        except Exception:
            try:
                device_arp = parse_ilo_arp_output(output)
                if not device_arp:
                    raise Exception("Custom parser returned empty result")
            except Exception as error:
                logger.error(f"Failed to parse ARP output for device {nautobot_device.name}: {error}")
                return

        # Обрабатываем ARP записи
        arp_batch = []
        skip_list = ['192.168.0.0', '192.168.0.1', '192.168.0.2', '192.168.0.3', '192.168.0.4', '192.168.0.5', '192.168.0.6']
        
        for arp_entry in device_arp:
            # Пропускаем служебные IP-адреса (только для Cisco IOS)
            if platform == 'cisco_ios' and any(sub in arp_entry['address'] for sub in skip_list):
                continue

            # Форматируем MAC-адрес и пропускаем неполные
            arp_entry['mac'] = format_mac_address(arp_entry['mac'])
            if str(arp_entry['mac']).upper() == 'IN-CO-MP-LE-TE':
                continue

            # Получаем DNS имя
            arp_entry['dns_name'] = get_dns_name(arp_entry['address'])
            arp_batch.append(arp_entry)

        # Массово обрабатываем батч
        process_ips_batch(nautobot_api, arp_batch, nautobot_device.name, discovered_tag_id, all_ips_cache, vrf_description)

    except Exception as error:
        logger.error(f'Error processing ARP table for device {nautobot_device.name} ({vrf_description}): {error}')


def process_device_arp(nautobot_device, nautobot_api, discovered_tag_id, all_ips_cache, platform):
    """Обрабатывает ARP записи для устройства (универсальная функция для IOS и NXOS)."""
    net_connect = netmiko_connect_with_retry(nautobot_device, platform)
    if not net_connect:
        return

    try:
        # Обрабатываем глобальную ARP таблицу
        get_and_process_arp_table(net_connect, nautobot_device, nautobot_api, platform, 
                                discovered_tag_id, all_ips_cache, 'show ip arp', "VRF GLOBAL")

        # Обрабатываем VRF
        device_vrfs = nautobot_api.ipam.vrfs.filter(device=nautobot_device.id)
        existing_vrf_in_device = {vrf.name: vrf.id for vrf in device_vrfs}

        for vrf_name, vrf_id in existing_vrf_in_device.items():
            try:
                # Проверяем состояние соединения
                if not net_connect.is_alive():
                    logger.warning(f"SSH connection lost for device {nautobot_device.name}, reconnecting...")
                    net_connect = netmiko_connect_with_retry(nautobot_device, platform)
                    if not net_connect:
                        logger.error(f"Failed to reconnect to device {nautobot_device.name}")
                        return

                # Обрабатываем VRF ARP таблицу
                get_and_process_arp_table(net_connect, nautobot_device, nautobot_api, platform, 
                                        discovered_tag_id, all_ips_cache, f'show ip arp vrf {vrf_name}', f"VRF {vrf_name}")

            except Exception as vrf_error:
                if "socket is closed" in str(vrf_error).lower() or "connection" in str(vrf_error).lower():
                    logger.warning(f'Connection lost during VRF {vrf_name} processing for device {nautobot_device.name}, skipping remaining VRFs')
                    break
                else:
                    logger.error(f'Error processing VRF {vrf_name} for device {nautobot_device.name}: {vrf_error}')

    except Exception as error:
        logger.error(f'Error processing device {nautobot_device.name}: {error}')
    finally:
        if net_connect and hasattr(net_connect, 'disconnect'):
            try:
                net_connect.disconnect()
            except Exception:
                pass


def add_arp_entry_to_nautobot():
    """Основная функция для добавления ARP записей в Nautobot."""
    start_time = time.time()
    api = nautobot_connection()

    # Получаем тег discovered_from_device
    discovered_tag_id = get_discovered_tag(api)

    # Загружаем все IP-адреса в кэш
    all_ips_cache = load_all_ips_cache(api)

    # Строим мапу тегов и фильтруем нужные устройства
    all_tags = list(api.extras.tags.all())
    tag_map = {tag.id: tag.name for tag in all_tags}
    
    devices = list(api.dcim.devices.all())
    target_devices = []

    for device in devices:
        tag_names = [tag_map.get(tag.id) for tag in (device.tags or [])]
        if 'raif_scripts' in tag_names:
            target_devices.append(device)

    print(f"Found {len(target_devices)} target devices")

    # Многопоточная обработка устройств
    with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
        for nautobot_device in target_devices:
            if nautobot_device.platform:
                platform_name = nautobot_device.platform.name
                if platform_name == 'Cisco NXOS':
                    executor.submit(process_device_arp, nautobot_device, api, discovered_tag_id, all_ips_cache, 'cisco_nxos')
                elif platform_name == 'Cisco IOS':
                    executor.submit(process_device_arp, nautobot_device, api, discovered_tag_id, all_ips_cache, 'cisco_ios')

    execution_time = time.time() - start_time
    print(f"Script execution completed in {execution_time:.2f} seconds")


if __name__ == "__main__":
    add_arp_entry_to_nautobot()
