import pynetbox
import urllib3
import re
from decouple import config
import time
from hpnapy import *
import concurrent.futures
import logging

# Настройка логирования
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger()

set_ipam_device = set()
set_hpna_device = set()
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

HPNA_LOGIN = config('HPNA_LOGIN')
HPNA_PASSWORD = config('HPNA_PASSWORD')
NETBOX_URL = config('NETBOX_URL')
NETBOX_TOKEN = config('NETBOX_TOKEN')

location_map = {
    'MSKX5': r'MSKX5',
    'MSK34': r'MSK34',
    'MSK70': r'MSK70',
    'MSKD8': r'MSKD8',
}

device_roles = {
    'BA-': 'LOAD BALANCER',
    'FX-': 'FABRIC NEXUS',
    'MS-': 'MULTILAYER SWITCH',
    'MX-': 'MULTILAYER SWITCH WITH ADDITIONAL FUNCTIONS',
    'ND-': 'NETWORK DEVICE',
    'QSW': 'SWITCH',
    'RT-': 'ROUTER',
    'SW-': 'SWITCH',
    'TS-': 'TERMINAL SERVER',
    'NX-': 'SWITCH',
    'FW-': 'FIREWALL'
}

device_role_map = {
    'QSW': 'switch',
    'MS-': 'switch',
    'MX-': 'switch',
    'SW-': 'switch',
    'NX-': 'switch',
    'FX-': 'switch'
}


def create_or_get_default_vrf(netbox_api):
    """Создает или получает default VRF"""
    try:
        default_vrf = netbox_api.ipam.vrfs.get(name='default')
        if not default_vrf:
            logger.info("Создаем default VRF")
            default_vrf = netbox_api.ipam.vrfs.create(
                name='default',
                rd='',
                description='Default VRF for management'
            )
        return default_vrf
    except Exception as e:
        logger.error(f"Ошибка при работе с default VRF: {e}")
        return None


def update_device_ip_address(netbox_api, device_hostname, hpna_device_ip):
    """Обновляет IP адрес устройства в NetBox"""
    try:
        # Получаем устройство
        device = netbox_api.dcim.devices.get(name=device_hostname)
        if not device:
            logger.error(f"Устройство {device_hostname} не найдено в NetBox")
            return False

        # Проверяем наличие default VRF
        default_vrf = create_or_get_default_vrf(netbox_api)
        if not default_vrf:
            logger.error(f"Не удалось получить default VRF для {device_hostname}")
            return False

        # Получаем или создаем mgmt interface
        mgmt_interface = netbox_api.dcim.interfaces.get(name='mgmt interface', device=device_hostname)
        if not mgmt_interface:
            logger.info(f"Создаем mgmt interface для {device_hostname}")
            mgmt_interface = netbox_api.dcim.interfaces.create(
                device=device.id,
                name='mgmt interface',
                type='virtual',
                mtu=1500,
                description='Management interface for device control',
                mgmt_only=True
            )

        # Формируем IP с маской /32 если её нет
        if '/' not in hpna_device_ip:
            ip_with_mask = f"{hpna_device_ip}/32"
        else:
            ip_with_mask = hpna_device_ip

        # Проверяем существование IP адреса
        existing_ip = netbox_api.ipam.ip_addresses.get(address=ip_with_mask)
        
        if not existing_ip:
            logger.info(f"Создаем IP адрес {ip_with_mask} для {device_hostname}")
            # Создаем новый IP адрес
            new_ip = netbox_api.ipam.ip_addresses.create(
                address=ip_with_mask,
                vrf=default_vrf.id,
                description=f'Management IP for {device_hostname}',
                assigned_object_type='dcim.interface',
                assigned_object_id=mgmt_interface.id
            )
            ip_to_assign = new_ip
        else:
            logger.info(f"IP адрес {ip_with_mask} уже существует, обновляем привязку для {device_hostname}")
            # Обновляем существующий IP
            existing_ip.update({
                'assigned_object_type': 'dcim.interface',
                'assigned_object_id': mgmt_interface.id,
                'vrf': default_vrf.id,
                'description': f'Management IP for {device_hostname}'
            })
            ip_to_assign = existing_ip

        # Устанавливаем как primary IP
        logger.info(f"Устанавливаем {ip_with_mask} как primary IP для {device_hostname}")
        device.primary_ip4 = ip_to_assign.id
        device.save()

        logger.info(f"✅ Успешно обновлен IP адрес для {device_hostname}: {ip_with_mask}")
        return True

    except Exception as e:
        logger.error(f"❌ Ошибка при обновлении IP адреса для {device_hostname}: {e}")
        return False


def fetch_device_role_for_vlan_group(device_hostname):
    device_role = 'UNKNOWN'
    for prefix, role in device_role_map.items():
        if device_hostname.lower().startswith(prefix.lower()):
            device_role = role
            break
    return device_role


def generate_device_model_slug(device_model):
    device_model_slug = device_model.lower()
    device_model_slug = re.sub(r'\s+', '_', device_model_slug)
    device_model_slug = re.sub(r'[^a-z0-9_]', '_', device_model_slug)
    return device_model_slug


def generate_slug(input_string):
    slug = input_string.lower()
    slug = re.sub(r'\s+', '_', slug)
    slug = re.sub(r'[^a-z0-9_]', '_', slug)
    return slug


def fetch_device_role(device_hostname):
    device_role = 'UNKNOWN'
    for prefix, role in device_roles.items():
        if device_hostname.startswith(prefix):
            device_role = role
            break
    return device_role


def netbox_connection():
    netbox_api = pynetbox.api(
        config('NETBOX_URL'),
        token=config('NETBOX_TOKEN'),
        threading=True
    )
    adapter = requests.adapters.HTTPAdapter(pool_connections=100, pool_maxsize=100)
    netbox_api.http_session.mount('http://', adapter)
    netbox_api.http_session.mount('https://', adapter)
    netbox_api.http_session.verify = False
    return netbox_api


def get_location(device_hostname):
    for location, pattern in location_map.items():
        if re.search(pattern, device_hostname):
            return location
    return 'BRANCH'


def hpna_connection():
    hpna_api = NAInterface("https://hpna.raiffeisen.ru", ssl_verify=False)
    hpna_api.login(config('HPNA_WEB_LOGIN'), config('HPNA_WEB_PASSWORD'))
    return hpna_api


def add_new_device_to_netbox(hpna_api_device_entry, netbox_api, hpna_api):
    device_hostname = (re.sub(r'\.(net\.pri|NET\.PRI)$', '', str(hpna_api_device_entry.hostName))).upper()
    set_hpna_device.add(str(device_hostname))
    hpna_device_ip = hpna_api_device_entry.primaryIPAddress
    hpna_device_vendor = hpna_api_device_entry.vendor
    hpna_device_model = hpna_api_device_entry.model

    try:
        hpna_device_family = hpna_api.show_device_family(ip=str(hpna_device_ip))
    except Exception:
        hpna_device_family = 'UNKNOWN'

    if hpna_device_vendor is None:
        hpna_device_vendor = 'UNKNOWN'

    if hpna_device_model is None:
        hpna_device_model = 'UNKNOWN'

    # Проверка валидности IP
    if hpna_device_ip is None or re.search(r"^\w+\.\w+\.\w+\.\w+$", device_hostname):
        logger.warning(f"Пропускаем {device_hostname}: некорректный IP или hostname")
        return

    if hpna_device_vendor in [' ', None, 'UNKNOWN', ''] and hpna_device_model in [' ', None, 'UNKNOWN', '']:
        logger.warning(f"Пропускаем {device_hostname}: неизвестные vendor и model")
        return

    device_hpna_location = get_location(device_hostname)
    device_hpna_role = fetch_device_role(device_hostname)

    device_role_slug = generate_slug(device_hpna_role)
    device_vendor_slug = generate_slug(hpna_device_vendor)
    device_model_slug = generate_device_model_slug(hpna_device_model)
    device_platform_slug = generate_slug(hpna_device_family)

    # Создание необходимых объектов в NetBox
    try:
        # Device Role
        if netbox_api.dcim.device_roles.get(name=device_hpna_role, slug=device_role_slug) is None:
            netbox_api.dcim.device_roles.create(name=device_hpna_role, slug=device_role_slug)

        # Tag
        if netbox_api.extras.tags.get(name=device_hpna_role, slug=device_role_slug) is None:
            netbox_api.extras.tags.create(name=device_hpna_role, slug=device_role_slug)

        # Manufacturer
        if netbox_api.dcim.manufacturers.get(name=hpna_device_vendor, slug=device_vendor_slug) is None:
            netbox_api.dcim.manufacturers.create(name=hpna_device_vendor, slug=device_vendor_slug)

        # Device Type
        if netbox_api.dcim.device_types.get(model=hpna_device_model) is None:
            device_vendor_nb = netbox_api.dcim.manufacturers.get(name=hpna_device_vendor, slug=device_vendor_slug)
            netbox_api.dcim.device_types.create(
                model=hpna_device_model, 
                manufacturer=device_vendor_nb.id,
                slug=device_model_slug
            )

        # Platform
        if netbox_api.dcim.platforms.get(name=hpna_device_family) is None:
            netbox_api.dcim.platforms.create(name=hpna_device_family, slug=device_platform_slug)

    except Exception as e:
        logger.error(f"Ошибка при создании объектов NetBox для {device_hostname}: {e}")

    # Получение ID объектов
    try:
        device_role_id = netbox_api.dcim.device_roles.get(name=device_hpna_role).id
    except:
        device_role_id = 10
        logger.warning(f'Не удалось получить device role для {device_hostname}')

    try:
        device_type_id = netbox_api.dcim.device_types.get(model=hpna_device_model).id
    except:
        device_type_id = 58
        logger.warning(f'Не удалось получить device type для {device_hostname}')

    try:
        site_id = netbox_api.dcim.sites.get(name=device_hpna_location).id
    except:
        site_id = 6
        logger.warning(f'Не удалось получить site для {device_hostname}')

    try:
        platform_id = netbox_api.dcim.platforms.get(name=hpna_device_family).id
    except:
        platform_id = 2
        logger.warning(f'Не удалось получить platform для {device_hostname}')

    # Проверяем существование устройства
    existing_device = netbox_api.dcim.devices.get(name=device_hostname)
    
    if not existing_device:
        # Создаем новое устройство
        logger.info(f"Создаем новое устройство: {device_hostname}")
        try:
            new_device = netbox_api.dcim.devices.create(
                name=device_hostname,
                role=device_role_id,
                device_type=device_type_id,
                site=site_id,
                platform=platform_id,
                status='active',
                tags=[{'name': device_hpna_role}, {'name': 'raif_scripts'}]
            )
            logger.info(f"✅ Создано устройство: {device_hostname}")
        except Exception as e:
            logger.error(f"❌ Ошибка при создании устройства {device_hostname}: {e}")
            return

    # Обновляем IP адрес (для новых и существующих устройств)
    update_device_ip_address(netbox_api, device_hostname, hpna_device_ip)

    # Создание VLAN Group
    vlan_group_slug = generate_slug(device_hostname)
    if netbox_api.ipam.vlan_groups.get(name=device_hostname) is None:
        try:
            netbox_api.ipam.vlan_groups.create(
                name=device_hostname,
                slug=vlan_group_slug,
                scope_type='dcim.site',
                scope_id=netbox_api.dcim.sites.get(name=device_hpna_location).id
            )
        except Exception as e:
            logger.error(f'Ошибка при создании VLAN группы для {device_hostname}: {e}')


def update_existing_devices_ip():
    """Обновляет IP адреса для всех существующих устройств с тегом raif_scripts"""
    logger.info("Обновление IP адресов для существующих устройств...")
    
    netbox_api = netbox_connection()
    hpna_api = hpna_connection()
    
    # Получаем все устройства из HPNA
    hpna_device_list = hpna_api.list_device()
    hpna_devices_dict = {}
    
    for device in hpna_device_list:
        hostname = (re.sub(r'\.(net\.pri|NET\.PRI|RBRU\.PRI|rbru\.pri)$', '', str(device.hostName))).upper()
        if device.primaryIPAddress:
            hpna_devices_dict[hostname] = device.primaryIPAddress

    # Получаем все устройства с тегом raif_scripts из NetBox
    netbox_devices = netbox_api.dcim.devices.filter(tag='raif_scripts')
    
    updated_count = 0
    for device in netbox_devices:
        if device.name in hpna_devices_dict:
            hpna_ip = hpna_devices_dict[device.name]
            
            # Проверяем текущий primary IP
            current_ip = device.primary_ip4
            expected_ip_with_mask = f"{hpna_ip}/32" if '/' not in hpna_ip else hpna_ip
            
            if not current_ip or str(current_ip.address) != expected_ip_with_mask:
                logger.info(f"Обновляем IP для {device.name}: {hpna_ip}")
                if update_device_ip_address(netbox_api, device.name, hpna_ip):
                    updated_count += 1
            else:
                logger.debug(f"IP адрес для {device.name} актуален: {current_ip.address}")
    
    logger.info(f"Обновлено IP адресов: {updated_count}")


def processing_hpna_device_list():
    start_time = time.time()
    
    logger.info("Начинаем синхронизацию устройств из HPNA...")
    
    netbox_api = netbox_connection()
    hpna_api = hpna_connection()
    
    # Создаем default VRF если его нет
    create_or_get_default_vrf(netbox_api)
    
    hpna_device_list = hpna_api.list_device()
    logger.info(f"Получено {len(hpna_device_list)} устройств из HPNA")

    # Параллельная обработка устройств
    with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
        futures = []
        for device in hpna_device_list:
            future = executor.submit(add_new_device_to_netbox, device, netbox_api, hpna_api)
            futures.append(future)
        
        # Ожидаем завершения всех задач
        for future in concurrent.futures.as_completed(futures):
            try:
                future.result()
            except Exception as e:
                logger.error(f"Ошибка при обработке устройства: {e}")

    # Обновляем IP адреса для существующих устройств
    update_existing_devices_ip()

    # Собираем информацию о устройствах для удаления
    devices_in_netbox = netbox_api.dcim.devices.filter(tag='raif_scripts')
    for device_netbox in devices_in_netbox:
        set_ipam_device.add(str(device_netbox.name))

    for device_hpna in hpna_device_list:
        hostname = (re.sub(r'\.(net\.pri|NET\.PRI|RBRU\.PRI|rbru\.pri)$', '', str(device_hpna.hostName))).upper()
        set_hpna_device.add(hostname)

    # Устройства для удаления
    devices_to_remove = set_ipam_device - set_hpna_device
    
    if devices_to_remove:
        logger.info(f"Найдено {len(devices_to_remove)} устройств для удаления")
        
        for device_name in devices_to_remove:
            try:
                device_to_delete = netbox_api.dcim.devices.get(name=device_name)
                if device_to_delete:
                    logger.info(f"Удаляем устройство: {device_name}")
                    
                    # Удаляем связанные объекты
                    if device_to_delete.primary_ip4:
                        device_to_delete.primary_ip4.delete()
                    
                    # Удаляем IP адреса устройства
                    device_ips = netbox_api.ipam.ip_addresses.filter(cf_Device=device_to_delete.id)
                    for ip in device_ips:
                        ip.delete()
                    
                    # Удаляем префиксы
                    device_prefixes = netbox_api.ipam.prefixes.filter(description=device_name)
                    for prefix in device_prefixes:
                        prefix.delete()
                    
                    # Удаляем VLAN группы и VLAN
                    try:
                        vlan_group = netbox_api.ipam.vlan_groups.get(name=device_name)
                        if vlan_group:
                            vlans = netbox_api.ipam.vlans.filter(group_id=vlan_group.id)
                            for vlan in vlans:
                                vlan.delete()
                            vlan_group.delete()
                    except Exception as e:
                        logger.error(f"Ошибка при удалении VLAN группы для {device_name}: {e}")
                    
                    # Удаляем VRF
                    device_vrfs = netbox_api.ipam.vrfs.filter(cf_device=device_to_delete.id)
                    for vrf in device_vrfs:
                        vrf.delete()
                    
                    # Удаляем устройство
                    device_to_delete.delete()
                    logger.info(f"✅ Удалено устройство: {device_name}")
                    
            except Exception as e:
                logger.error(f"❌ Ошибка при удалении устройства {device_name}: {e}")

    total_time = time.time() - start_time
    logger.info(f"Синхронизация завершена за {total_time:.2f} секунд")


if __name__ == "__main__":
    processing_hpna_device_list()
